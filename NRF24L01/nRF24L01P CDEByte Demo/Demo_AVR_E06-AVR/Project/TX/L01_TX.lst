Interrupt Vectors
    00000 C368      RJMP	__text_start|__start

Program Code (text area)
__text_start|__start:
    00369 E5CF      LDI	R28,0x5F
    0036A E0D4      LDI	R29,4
    0036B BFCD      OUT	0x3D,R28
    0036C BFDE      OUT	0x3E,R29
    0036D 51CE      SUBI	R28,0x1E
    0036E 40D0      SBCI	R29,0
    0036F EA0A      LDI	R16,0xAA
    00370 8308      ST	Y,R16
    00371 2400      CLR	R0
    00372 E8ED      LDI	R30,0x8D
    00373 E0F0      LDI	R31,0
    00374 E010      LDI	R17,0
    00375 38ED      CPI	R30,0x8D
    00376 07F1      CPC	R31,R17
    00377 F011      BEQ	0x037A
    00378 9201      ST	Z+,R0
    00379 CFFB      RJMP	0x0375
    0037A 8300      ST	Z,R16
    0037B EAE5      LDI	R30,0xA5
    0037C E0F6      LDI	R31,6
    0037D E6A0      LDI	R26,0x60
    0037E E0B0      LDI	R27,0
    0037F E016      LDI	R17,6
    00380 E000      LDI	R16,0
    00381 BF0B      OUT	0x3B,R16
    00382 3DE2      CPI	R30,0xD2
    00383 07F1      CPC	R31,R17
    00384 F021      BEQ	0x0389
    00385 95C8      LPM
    00386 9631      ADIW	R30,1
    00387 920D      ST	X+,R0
    00388 CFF9      RJMP	0x0382
    00389 D001      RCALL	_main
_exit:
    0038A CFFF      RJMP	_exit
_main:
  x                    --> Y,+3
  tx_couter            --> R20
  testbuffer           --> Y,+6
  itmp                 --> R22
  tmp                  --> R10
  dly                  --> Y,+2
    0038B 9760      SBIW	R28,0x10
FILE: F:\产品\ODMPRO~1\E06-RFTB\E06-AVR\DEMO_AVR\nRF24L01P\Project\TX\main.c
(0001) 
(0002) 
(0003) #include "nRF24L01.h"
(0004) #include "board.h"
(0005) #include "Oled.h"
(0006) 
(0007) void main( void )
(0008) {
(0009) 	INT32U dly;
(0010)     INT8U tmp,x,testbuffer[10] = {"00000"};
    0038C E286      LDI	R24,0x26
    0038D E090      LDI	R25,0
    0038E 01FE      MOVW	R30,R28
    0038F 9636      ADIW	R30,6
    00390 E00A      LDI	R16,0xA
    00391 E010      LDI	R17,0
    00392 93FA      ST	-Y,R31
    00393 93EA      ST	-Y,R30
    00394 939A      ST	-Y,R25
    00395 938A      ST	-Y,R24
    00396 D47A      RCALL	asgncblk
(0011) 	INT16U tx_couter = 0, itmp;
    00397 2744      CLR	R20
    00398 2755      CLR	R21
(0012) 
(0013) 	SPI_Initial( );
    00399 D0BE      RCALL	_SPI_Initial
(0014) 	GPIO_Initial( );
    0039A D0C7      RCALL	_GPIO_Initial
(0015) 
(0016) 
(0017) 	//初始化L01+的控制口CE = 0
(0018) 	L01_CE_LOW( );
    0039B 98C7      CBI	0x18,7
    0039C 9ABF      SBI	0x17,7
(0019) 
(0020) 	//初始化L01+的控制口IRQ,使用查询方式
(0021) 	PORTB |= ( 1<<6 );
    0039D 9AC6      SBI	0x18,6
(0022) 	DDRB  &= ~( 1<<6 );
    0039E 98BE      CBI	0x17,6
(0023) 
(0024) 	//L01+的操作，已经被建成C库，见nRF24L01.h文件，提供SPI和CSN操作，即可调用其内部所有函数。
(0025) 	//用户无需再关心L01+的寄存器操作问题。
(0026) 	L01_Init( );
    0039F D26D      RCALL	_L01_Init
(0027) 	L01_SetTRMode( TX_MODE );
    003A0 2700      CLR	R16
    003A1 D240      RCALL	_L01_SetTRMode
(0028) 	L01_WriteHoppingPoint( 0 );
    003A2 2700      CLR	R16
    003A3 D232      RCALL	_L01_WriteHoppingPoint
(0029) 	//L01_SetSpeed( SPD_250K );
(0030) 
(0031) 	//关闭LED
(0032) 	LED_Off( );
    003A4 B382      IN	R24,0x12
    003A5 6083      ORI	R24,3
    003A6 BB82      OUT	0x12,R24
    003A7 B381      IN	R24,0x11
    003A8 6083      ORI	R24,3
    003A9 BB81      OUT	0x11,R24
(0033) 
(0034) 	LCD_Init( );
    003AA D39B      RCALL	_LCD_Init
(0035) 	LCD_Dis_Logo( );
    003AB D2C7      RCALL	_LCD_Dis_Logo
(0036) 	LCD_Dis_Str( 2,24,"AVR board" );
    003AC E882      LDI	R24,0x82
    003AD E090      LDI	R25,0
    003AE 8399      STD	Y+1,R25
    003AF 8388      ST	Y,R24
    003B0 E128      LDI	R18,0x18
    003B1 E002      LDI	R16,2
    003B2 D350      RCALL	_LCD_Dis_Str
(0037)     LCD_Dis_Str( 4,0,"yhmcu.taobao.com" );
    003B3 E781      LDI	R24,0x71
    003B4 E090      LDI	R25,0
    003B5 8399      STD	Y+1,R25
    003B6 8388      ST	Y,R24
    003B7 2722      CLR	R18
    003B8 E004      LDI	R16,4
    003B9 D349      RCALL	_LCD_Dis_Str
(0038)     LCD_Dis_Str( 6,0,"24L01+:TX " );
    003BA E686      LDI	R24,0x66
    003BB E090      LDI	R25,0
    003BC 8399      STD	Y+1,R25
    003BD 8388      ST	Y,R24
    003BE 2722      CLR	R18
    003BF E006      LDI	R16,6
    003C0 D342      RCALL	_LCD_Dis_Str
(0039)     LCD_Dis_Str( 6, 80, (char*)testbuffer );
    003C1 01CE      MOVW	R24,R28
    003C2 9606      ADIW	R24,6
    003C3 8399      STD	Y+1,R25
    003C4 8388      ST	Y,R24
    003C5 E520      LDI	R18,0x50
    003C6 E006      LDI	R16,6
    003C7 D33B      RCALL	_LCD_Dis_Str
    003C8 C087      RJMP	0x0450
(0040) 
(0041) 	/*功能：
(0042) 	1、此为发射程序，每隔一段延时，发送一个字符串。
(0043) 	2、用一个LED指示发射开始，另一个LED指示发射状态
(0044) 	3、发射开始：LED闪烁一次，发射结果：显示在OLED
(0045) 	4、发射采用自动应答模式，若取消，通信距离将延长。
(0046) 	*/
(0047) 	while( 1 )
(0048) 	{
(0049)         //延时发射
(0050)         for( dly = 0; dly < 5000; dly ++ );
    003C9 E080      LDI	R24,0
    003CA 838A      STD	Y+2,R24
    003CB 838B      STD	Y+3,R24
    003CC 838C      STD	Y+4,R24
    003CD 838D      STD	Y+5,R24
    003CE C010      RJMP	0x03DF
    003CF E081      LDI	R24,1
    003D0 E090      LDI	R25,0
    003D1 E0A0      LDI	R26,0
    003D2 E0B0      LDI	R27,0
    003D3 802A      LDD	R2,Y+2
    003D4 803B      LDD	R3,Y+3
    003D5 804C      LDD	R4,Y+4
    003D6 805D      LDD	R5,Y+5
    003D7 0E28      ADD	R2,R24
    003D8 1E39      ADC	R3,R25
    003D9 1E4A      ADC	R4,R26
    003DA 1E5B      ADC	R5,R27
    003DB 822A      STD	Y+2,R2
    003DC 823B      STD	Y+3,R3
    003DD 824C      STD	Y+4,R4
    003DE 825D      STD	Y+5,R5
    003DF E888      LDI	R24,0x88
    003E0 E193      LDI	R25,0x13
    003E1 E0A0      LDI	R26,0
    003E2 E0B0      LDI	R27,0
    003E3 802A      LDD	R2,Y+2
    003E4 803B      LDD	R3,Y+3
    003E5 804C      LDD	R4,Y+4
    003E6 805D      LDD	R5,Y+5
    003E7 1628      CP	R2,R24
    003E8 0639      CPC	R3,R25
    003E9 064A      CPC	R4,R26
    003EA 065B      CPC	R5,R27
    003EB F318      BCS	0x03CF
(0051)         //发射一个字符串
(0052)         L01_FlushRX( );
    003EC D0C9      RCALL	_L01_FlushRX
(0053)         L01_FlushTX( );
    003ED D0C1      RCALL	_L01_FlushTX
(0054)         L01_WriteTXPayload_Ack( (INT8U*)"123\r\n", strlen( "123\r\n" ) );
    003EE E600      LDI	R16,0x60
    003EF E010      LDI	R17,0
    003F0 D3A1      RCALL	_strlen
    003F1 2F20      MOV	R18,R16
    003F2 E600      LDI	R16,0x60
    003F3 E010      LDI	R17,0
    003F4 D120      RCALL	_L01_WriteTXPayload_Ack
(0055)         L01_CE_HIGH( );	// CE = 1,启动发射
    003F5 9AC7      SBI	0x18,7
    003F6 9ABF      SBI	0x17,7
(0056) 
(0057)         //等待发射中断产生，判断发射失败或成功
(0058)         while( PINB & ( 1<<6 ) );
    003F7 99B6      SBIC	0x16,6
    003F8 CFFE      RJMP	0x03F7
(0059)         while( ( tmp = L01_ReadIRQSource( ) ) == 0 );
    003F9 D0ED      RCALL	_L01_ReadIRQSource
    003FA 2EA0      MOV	R10,R16
    003FB 20AA      TST	R10
    003FC F3E1      BEQ	0x03F9
(0060)         L01_CE_LOW( );	// 发射完毕，CE = 0，省电
    003FD 98C7      CBI	0x18,7
    003FE 9ABF      SBI	0x17,7
(0061) 
(0062)         if( tmp & ( 1<<TX_DS ) )
    003FF FF05      SBRS	R16,5
    00400 C043      RJMP	0x0444
(0063)         {
(0064)             //发射成功，LED翻转
(0065)             LED_Toggle( );
    00401 E083      LDI	R24,3
    00402 B222      IN	R2,0x12
    00403 2628      EOR	R2,R24
    00404 BA22      OUT	0x12,R2
    00405 B381      IN	R24,0x11
    00406 6083      ORI	R24,3
    00407 BB81      OUT	0x11,R24
(0066) 
(0067)             tx_couter ++;
    00408 5F4F      SUBI	R20,0xFF
    00409 4F5F      SBCI	R21,0xFF
(0068)             itmp = tx_couter;
    0040A 01BA      MOVW	R22,R20
(0069)             testbuffer[0] = ( itmp / 10000 ) + '0';
    0040B E120      LDI	R18,0x10
    0040C E237      LDI	R19,0x27
    0040D 018B      MOVW	R16,R22
    0040E D391      RCALL	div16u
    0040F 01C8      MOVW	R24,R16
    00410 96C0      ADIW	R24,0x30
    00411 838E      STD	Y+6,R24
(0070)             itmp %= 10000;
    00412 E120      LDI	R18,0x10
    00413 E237      LDI	R19,0x27
    00414 018B      MOVW	R16,R22
    00415 D388      RCALL	mod16u
    00416 01B8      MOVW	R22,R16
(0071)             testbuffer[1] = ( itmp / 1000 ) + '0';
    00417 EE28      LDI	R18,0xE8
    00418 E033      LDI	R19,3
    00419 D386      RCALL	div16u
    0041A 01C8      MOVW	R24,R16
    0041B 96C0      ADIW	R24,0x30
    0041C 838F      STD	Y+7,R24
(0072)             itmp %= 1000;
    0041D EE28      LDI	R18,0xE8
    0041E E033      LDI	R19,3
    0041F 018B      MOVW	R16,R22
    00420 D37D      RCALL	mod16u
    00421 01B8      MOVW	R22,R16
(0073)             testbuffer[2] = ( itmp / 100 ) + '0';
    00422 E624      LDI	R18,0x64
    00423 E030      LDI	R19,0
    00424 D37B      RCALL	div16u
    00425 01C8      MOVW	R24,R16
    00426 96C0      ADIW	R24,0x30
    00427 8788      STD	Y+8,R24
(0074)             itmp %= 100;
    00428 E624      LDI	R18,0x64
    00429 E030      LDI	R19,0
    0042A 018B      MOVW	R16,R22
    0042B D372      RCALL	mod16u
    0042C 01B8      MOVW	R22,R16
(0075)             testbuffer[3] = ( itmp / 10 ) + '0';
    0042D E02A      LDI	R18,0xA
    0042E E030      LDI	R19,0
    0042F D370      RCALL	div16u
    00430 01C8      MOVW	R24,R16
    00431 96C0      ADIW	R24,0x30
    00432 8789      STD	Y+9,R24
(0076)             itmp %= 10;
    00433 E02A      LDI	R18,0xA
    00434 E030      LDI	R19,0
    00435 018B      MOVW	R16,R22
    00436 D367      RCALL	mod16u
    00437 01B8      MOVW	R22,R16
(0077)             testbuffer[4] = itmp + '0';
    00438 01CB      MOVW	R24,R22
    00439 96C0      ADIW	R24,0x30
    0043A 878A      STD	Y+10,R24
(0078)             testbuffer[5] = 0;
    0043B 2422      CLR	R2
    0043C 862B      STD	Y+11,R2
(0079)             LCD_Dis_Str( 6, 80, (char*)testbuffer );
    0043D 01CE      MOVW	R24,R28
    0043E 9606      ADIW	R24,6
    0043F 8399      STD	Y+1,R25
    00440 8388      ST	Y,R24
    00441 E520      LDI	R18,0x50
    00442 E006      LDI	R16,6
    00443 D2BF      RCALL	_LCD_Dis_Str
(0080)         }
(0081)         if( tmp & ( 1<<MAX_RT ) )
    00444 FEA4      SBRS	R10,4
    00445 C006      RJMP	0x044C
(0082)         {
(0083)             //发射失败，LED长亮
(0084) 			LED_On( );
    00446 B382      IN	R24,0x12
    00447 7F8C      ANDI	R24,0xFC
    00448 BB82      OUT	0x12,R24
    00449 B381      IN	R24,0x11
    0044A 6083      ORI	R24,3
    0044B BB81      OUT	0x11,R24
(0085)         }
(0086)         if( tmp & ( 1<<RX_DR )  )
    0044C FEA6      SBRS	R10,6
    0044D C000      RJMP	0x044E
(0087)         {
(0088) 
(0089)         }
(0090)         L01_ClearIRQ( IRQ_ALL );
    0044E E700      LDI	R16,0x70
    0044F D085      RCALL	_L01_ClearIRQ
    00450 CF78      RJMP	0x03C9
    00451 9660      ADIW	R28,0x10
    00452 9508      RET
FILE: F:\产品\ODMPRO~1\E06-RFTB\E06-AVR\DEMO_AVR\nRF24L01P\Source\board.c
(0001) /*
(0002) ================================================================================
(0003) Function : Operation for SI446x
(0004) 网址：http://shop57165217.taobao.com
(0005) 作者：李勇  原  亿和电子工作室  现 亿佰特电子科技有限公司
(0006) TEL：18615799380, e-mail: yihe_liyong@126.com
(0007) ================================================================================
(0008) */
(0009) #include "board.h"
(0010) 
(0011) /*
(0012) =================================================================================
(0013) SPI_ExchangeByte( );
(0014) Function : Exchange a byte via the SPI bus
(0015) INTPUT   : input, The input byte
(0016) OUTPUT   : The output byte from SPI bus
(0017) =================================================================================
(0018) */
(0019) INT8U SPI_ExchangeByte( INT8U input )
(0020) {
(0021)     SPDR = input;
_SPI_ExchangeByte:
  input                --> R16
    00453 B90F      OUT	0x0F,R16
(0022) 	while ( !(SPSR & (1<<SPIF)) );
    00454 9B77      SBIS	0x0E,7
    00455 CFFE      RJMP	0x0454
(0023) 	return SPDR;
    00456 B10F      IN	R16,0x0F
    00457 9508      RET
(0024) }
(0025) /*
(0026) =================================================================================
(0027) SPI_Initial( );
(0028) Function : Initialize the SPI bus
(0029) INTPUT   : None
(0030) OUTPUT   : None
(0031) =================================================================================
(0032) */
(0033) void SPI_Initial( void )
(0034) {
(0035)     /*IO config*/
(0036)     PORTB |= ( 1<<3 ) | ( 1<<5 ) | ( 1<<2 );
_SPI_Initial:
    00458 B388      IN	R24,0x18
    00459 628C      ORI	R24,0x2C
    0045A BB88      OUT	0x18,R24
(0037)     DDRB |= ( 1<<3 ) | ( 1<<5 ) | ( 1<<2 ) | ( 1<<4 );
    0045B B387      IN	R24,0x17
    0045C 638C      ORI	R24,0x3C
    0045D BB87      OUT	0x17,R24
(0038)     DDRB &= ~( 1<<4 );
    0045E 98BC      CBI	0x17,4
(0039)     SPCR = (1<<SPE) | (1<<MSTR);
    0045F E580      LDI	R24,0x50
    00460 B98D      OUT	0x0D,R24
    00461 9508      RET
(0040) }
(0041) /*
(0042) =================================================================================
(0043) GPIO_Initial( );
(0044) Function : Initialize the other GPIOs of the board
(0045) INTPUT   : None
(0046) OUTPUT   : None
(0047) =================================================================================
(0048) */
(0049) void GPIO_Initial( void )
(0050) {
(0051)     PORTB &= ~( 1<<0 );
_GPIO_Initial:
    00462 98C0      CBI	0x18,0
(0052)     DDRB  |= ( 1<<0 );
    00463 9AB8      SBI	0x17,0
    00464 9508      RET
FILE: F:\产品\ODMPRO~1\E06-RFTB\E06-AVR\DEMO_AVR\nRF24L01P\Source\nRF24L01.c
(0001) /*
(0002) ================================================================================
(0003) Copyright(c)  Yihe Embedded Studio, All rights reserved.
(0004)               www.yhmcu.com
(0005)               http://yhmcu.taobao.com
(0006) 
(0007) File Name   : nRF24L01.c
(0008) Description : nRF24L01 low level operations and configurations.
(0009) Author      : ShawZhang,LiYong
(0010) Date        : 2012-4-17 9:08:36
(0011) Version     : 2.0
(0012) Compiler    : Any
(0013) Note        : None
(0014) ================================================================================
(0015) */
(0016) #define _nRF24L01_C_
(0017) #include "nRF24L01.h"
(0018) 
(0019) INT8U CE_Status = 0;
(0020) /*
(0021) ================================================================================
(0022) Function : L01_GetCEStatus( )
(0023) Description : Get the status of the CE PIN
(0024) Input : NONE
(0025) Output: 1:CE=1, 0:CE=0
(0026) ================================================================================
(0027) */
(0028) INT8U L01_GetCEStatus( void )
(0029) {
(0030) 	return CE_Status;
_L01_GetCEStatus:
    00465 9100 008C LDS	R16,CE_Status
    00467 9508      RET
(0031) }
(0032) /*
(0033) ================================================================================
(0034) Function : L01_SetCE( )
(0035) Description : Set the CE PIN as 1 or 0
(0036) Input : -status, 1: CE=1, 0: CE=0
(0037) Output: None
(0038) ================================================================================
(0039) */
(0040) void L01_SetCE( INT8U status )
(0041) {
(0042) 	CE_Status = status;
_L01_SetCE:
  status               --> R16
    00468 9300 008C STS	CE_Status,R16
(0043) 	if( status == 0 )  { L01_CE_LOW( ); }
    0046A 2300      TST	R16
    0046B F419      BNE	0x046F
    0046C 98C7      CBI	0x18,7
    0046D 9ABF      SBI	0x17,7
    0046E C002      RJMP	0x0471
(0044) 	else               { L01_CE_HIGH( ); }
    0046F 9AC7      SBI	0x18,7
    00470 9ABF      SBI	0x17,7
    00471 9508      RET
_L01_ReadSingleReg:
  btmp                 --> R10
  Addr                 --> R10
    00472 92AA      ST	-Y,R10
    00473 2EA0      MOV	R10,R16
(0045) }
(0046) /*
(0047) ================================================================================
(0048) Function : L01_ReadSingleReg( )
(0049) Description : Read a single register of nRF24L01
(0050) Input : -Addr, The address of the register
(0051) Output: The value read from the register
(0052) ================================================================================
(0053) */
(0054) INT8U L01_ReadSingleReg( INT8U Addr )
(0055) {
(0056)     INT8U btmp;
(0057)     L01_CSN_LOW( );
    00474 98C2      CBI	0x18,2
    00475 9ABA      SBI	0x17,2
(0058)     SPI_ExchangeByte( R_REGISTER | Addr );
    00476 2D0A      MOV	R16,R10
    00477 DFDB      RCALL	_SPI_ExchangeByte
(0059)     btmp = SPI_ExchangeByte( 0xFF );
    00478 EF0F      LDI	R16,0xFF
    00479 DFD9      RCALL	_SPI_ExchangeByte
    0047A 2EA0      MOV	R10,R16
(0060)     L01_CSN_HIGH( );
    0047B 9AC2      SBI	0x18,2
    0047C 9ABA      SBI	0x17,2
(0061)     return btmp;
    0047D 90A9      LD	R10,Y+
    0047E 9508      RET
_L01_WriteSingleReg:
  tmp                  --> R10
  Value                --> R12
  Addr                 --> R20
    0047F D371      RCALL	push_xgset303C
    00480 2EC2      MOV	R12,R18
    00481 2F40      MOV	R20,R16
(0062) }
(0063) /*
(0064) ================================================================================
(0065) Function : L01_ReadMultiReg( )
(0066) Description : Read several registers of nRF24L01
(0067) Input : -StartAddr, The start address of the registers
(0068)         -nBytes, How many registers do you want to read
(0069)         -pBuff, The buffer to save the values
(0070) Output: None
(0071) ================================================================================
(0072) */
(0073) /*void L01_ReadMultiReg( INT8U StartAddr, INT8U nBytes, INT8U *pBuff )
(0074) {
(0075)     INT8U btmp;
(0076)     L01_CSN_LOW( );
(0077)     SPI_ExchangeByte( R_REGISTER | StartAddr );
(0078)     for( btmp = 0; btmp < nBytes; btmp ++ )
(0079)     {
(0080)         *( pBuff + btmp ) = SPI_ExchangeByte( 0xFF );
(0081)     }
(0082)     L01_CSN_HIGH( );
(0083) }
(0084) 
(0085) ================================================================================
(0086) Function : L01_WriteSingleReg( )
(0087) Description : Write a single byte to a register
(0088) Input : -Addr, The address of the register
(0089)         -Value, The value to be written
(0090) Output: None
(0091) ================================================================================
(0092) */
(0093) void L01_WriteSingleReg( INT8U Addr, INT8U Value )
(0094) {
(0095) 	INT8U tmp = L01_GetCEStatus( );
    00482 DFE2      RCALL	_L01_GetCEStatus
    00483 2EA0      MOV	R10,R16
(0096) 	L01_SetCE( 0 );
    00484 2700      CLR	R16
    00485 DFE2      RCALL	_L01_SetCE
(0097)     L01_CSN_LOW( );
    00486 98C2      CBI	0x18,2
    00487 9ABA      SBI	0x17,2
(0098)     SPI_ExchangeByte( W_REGISTER | Addr );
    00488 2F04      MOV	R16,R20
    00489 6200      ORI	R16,0x20
    0048A DFC8      RCALL	_SPI_ExchangeByte
(0099)     SPI_ExchangeByte( Value );
    0048B 2D0C      MOV	R16,R12
    0048C DFC6      RCALL	_SPI_ExchangeByte
(0100)     L01_CSN_HIGH( );
    0048D 9AC2      SBI	0x18,2
    0048E 9ABA      SBI	0x17,2
(0101) 	L01_SetCE( tmp );
    0048F 2D0A      MOV	R16,R10
    00490 DFD7      RCALL	_L01_SetCE
    00491 C366      RJMP	pop_xgset303C
_L01_WriteMultiReg:
  tmp                  --> R10
  i                    --> R12
  Length               --> R14
  pBuff                --> R20
  StartAddr            --> R22
    00492 D33B      RCALL	push_xgsetF0FC
    00493 01A9      MOVW	R20,R18
    00494 2F60      MOV	R22,R16
    00495 84EA      LDD	R14,Y+10
(0102) }
(0103) /*
(0104) ================================================================================
(0105) Function : L01_WriteMultiReg( )
(0106) Description : Read several registers of nRF24L01
(0107) Input : -StartAddr, The start address of the registers
(0108)         -pBuff, The buffer store the values
(0109)         -Length, How many registers do you want to write
(0110) Output: None
(0111) ================================================================================
(0112) */
(0113) void L01_WriteMultiReg( INT8U StartAddr, INT8U *pBuff, INT8U Length )
(0114) {
(0115)     INT8U i;
(0116) 	INT8U tmp = L01_GetCEStatus( );
    00496 DFCE      RCALL	_L01_GetCEStatus
    00497 2EA0      MOV	R10,R16
(0117) 	L01_SetCE( 0 );
    00498 2700      CLR	R16
    00499 DFCE      RCALL	_L01_SetCE
(0118)     L01_CSN_LOW( );
    0049A 98C2      CBI	0x18,2
    0049B 9ABA      SBI	0x17,2
(0119)     SPI_ExchangeByte( W_REGISTER | StartAddr );
    0049C 2F06      MOV	R16,R22
    0049D 6200      ORI	R16,0x20
    0049E DFB4      RCALL	_SPI_ExchangeByte
(0120)     for( i = 0; i < Length; i ++ )
    0049F 24CC      CLR	R12
    004A0 C007      RJMP	0x04A8
(0121)     {
(0122)         SPI_ExchangeByte( *( pBuff + i ) );
    004A1 2DEC      MOV	R30,R12
    004A2 27FF      CLR	R31
    004A3 0FE4      ADD	R30,R20
    004A4 1FF5      ADC	R31,R21
    004A5 8100      LD	R16,Z
    004A6 DFAC      RCALL	_SPI_ExchangeByte
    004A7 94C3      INC	R12
    004A8 14CE      CP	R12,R14
    004A9 F3B8      BCS	0x04A1
(0123)     }
(0124)     L01_CSN_HIGH( );
    004AA 9AC2      SBI	0x18,2
    004AB 9ABA      SBI	0x17,2
(0125) 	L01_SetCE( tmp );
    004AC 2D0A      MOV	R16,R10
    004AD DFBA      RCALL	_L01_SetCE
    004AE C314      RJMP	pop_xgsetF0FC
(0126) }
(0127) /*
(0128) ================================================================================
(0129) Function : L01_FlushTX( )
(0130) Description : Flush the TX buffer
(0131) Input : None
(0132) Output: None
(0133) ================================================================================
(0134) */
(0135) void L01_FlushTX( void )
(0136) {
(0137)     L01_CSN_LOW( );
_L01_FlushTX:
    004AF 98C2      CBI	0x18,2
    004B0 9ABA      SBI	0x17,2
(0138)     SPI_ExchangeByte( FLUSH_TX );
    004B1 EE01      LDI	R16,0xE1
    004B2 DFA0      RCALL	_SPI_ExchangeByte
(0139)     L01_CSN_HIGH( );
    004B3 9AC2      SBI	0x18,2
    004B4 9ABA      SBI	0x17,2
    004B5 9508      RET
(0140) }
(0141) /*
(0142) ================================================================================
(0143) Function : L01_FlushRX( )
(0144) Description : Flush the RX buffer
(0145) Input : None
(0146) Output: None
(0147) ================================================================================
(0148) */
(0149) void L01_FlushRX( void )
(0150) {
(0151)     L01_CSN_LOW( );
_L01_FlushRX:
    004B6 98C2      CBI	0x18,2
    004B7 9ABA      SBI	0x17,2
(0152)     SPI_ExchangeByte( FLUSH_RX );
    004B8 EE02      LDI	R16,0xE2
    004B9 DF99      RCALL	_SPI_ExchangeByte
(0153)     L01_CSN_HIGH( );
    004BA 9AC2      SBI	0x18,2
    004BB 9ABA      SBI	0x17,2
    004BC 9508      RET
(0154) }
(0155) /*
(0156) ================================================================================
(0157) Function : L01_ReuseTXPayload( )
(0158) Description : Reuse the last transmitted payload
(0159) Input : None
(0160) Output: None
(0161) ================================================================================
(0162) */
(0163) void L01_ReuseTXPayload( void )
(0164) {
(0165)     L01_CSN_LOW( );
_L01_ReuseTXPayload:
    004BD 98C2      CBI	0x18,2
    004BE 9ABA      SBI	0x17,2
(0166)     SPI_ExchangeByte( REUSE_TX_PL );
    004BF EE03      LDI	R16,0xE3
    004C0 DF92      RCALL	_SPI_ExchangeByte
(0167)     L01_CSN_HIGH( );
    004C1 9AC2      SBI	0x18,2
    004C2 9ABA      SBI	0x17,2
    004C3 9508      RET
(0168) }
(0169) /*
(0170) ================================================================================
(0171) Function : L01_Nop( )
(0172) Description : nop operation of nRF24L01
(0173) Input : None
(0174) Output: None
(0175) ================================================================================
(0176) */
(0177) void L01_Nop( void )
(0178) {
(0179)     L01_CSN_LOW( );
_L01_Nop:
    004C4 98C2      CBI	0x18,2
    004C5 9ABA      SBI	0x17,2
(0180)     SPI_ExchangeByte( L01_NOP );
    004C6 EF0F      LDI	R16,0xFF
    004C7 DF8B      RCALL	_SPI_ExchangeByte
(0181)     L01_CSN_HIGH( );
    004C8 9AC2      SBI	0x18,2
    004C9 9ABA      SBI	0x17,2
    004CA 9508      RET
_L01_ReadStatusReg:
  Status               --> R10
    004CB 92AA      ST	-Y,R10
(0182) }
(0183) /*
(0184) ================================================================================
(0185) Function : L01_ReadStatusReg( )
(0186) Description : Read statu register of nRF24L01
(0187) Input : None
(0188) Output: Statu register of nRF24L01
(0189) ================================================================================
(0190) */
(0191) INT8U L01_ReadStatusReg( void )
(0192) {
(0193)     INT8U Status;
(0194)     L01_CSN_LOW( );
    004CC 98C2      CBI	0x18,2
    004CD 9ABA      SBI	0x17,2
(0195)     Status = SPI_ExchangeByte( R_REGISTER + L01REG_STATUS );
    004CE E007      LDI	R16,7
    004CF DF83      RCALL	_SPI_ExchangeByte
    004D0 2EA0      MOV	R10,R16
(0196)     L01_CSN_HIGH( );
    004D1 9AC2      SBI	0x18,2
    004D2 9ABA      SBI	0x17,2
(0197)     return Status;
    004D3 90A9      LD	R10,Y+
    004D4 9508      RET
_L01_ClearIRQ:
  btmp                 --> R10
  IRQ_Source           --> R20
    004D5 92AA      ST	-Y,R10
    004D6 934A      ST	-Y,R20
    004D7 2F40      MOV	R20,R16
(0198) }
(0199) /*
(0200) ================================================================================
(0201) Function : L01_ClearIRQ( )
(0202) Description : Clear IRQ cuased by nRF24L01
(0203) Input : None
(0204) Output: None
(0205) ================================================================================
(0206) */
(0207) void L01_ClearIRQ( INT8U IRQ_Source )
(0208) {
(0209)     INT8U btmp = 0;
(0210) 
(0211)     IRQ_Source &= ( 1<<RX_DR ) | ( 1<<TX_DS ) | ( 1<<MAX_RT );
    004D8 7740      ANDI	R20,0x70
(0212)     btmp = L01_ReadStatusReg( );
    004D9 DFF1      RCALL	_L01_ReadStatusReg
    004DA 2EA0      MOV	R10,R16
(0213)     L01_CSN_LOW( );
    004DB 98C2      CBI	0x18,2
    004DC 9ABA      SBI	0x17,2
(0214) 	L01_WriteSingleReg( L01REG_STATUS, IRQ_Source | btmp );
    004DD 2F24      MOV	R18,R20
    004DE 2B20      OR	R18,R16
    004DF E007      LDI	R16,7
    004E0 DF9E      RCALL	_L01_WriteSingleReg
(0215)     L01_CSN_HIGH( );
    004E1 9AC2      SBI	0x18,2
    004E2 9ABA      SBI	0x17,2
(0216)     L01_ReadStatusReg( );
    004E3 DFE7      RCALL	_L01_ReadStatusReg
    004E4 9149      LD	R20,Y+
    004E5 90A9      LD	R10,Y+
    004E6 9508      RET
(0217) }
(0218) /*
(0219) ================================================================================
(0220) Function : L01_ReadIRQSource( )
(0221) Description : Read the IRQ source of nRF24L01+
(0222) Input : None
(0223) Output: IRQ source mask code
(0224) ================================================================================
(0225) */
(0226) INT8U L01_ReadIRQSource( void )
(0227) {
(0228)     return ( L01_ReadStatusReg( ) & ( ( 1<<RX_DR ) | ( 1<<TX_DS ) | ( 1<<MAX_RT ) ) );
_L01_ReadIRQSource:
    004E7 DFE3      RCALL	_L01_ReadStatusReg
    004E8 7700      ANDI	R16,0x70
    004E9 9508      RET
_L01_ReadTopFIFOWidth:
  btmp                 --> R10
    004EA 92AA      ST	-Y,R10
(0229) }
(0230) /*
(0231) ================================================================================
(0232) Function : L01_ReadTopFIFOWidth( )
(0233) Description : Read the payload width of the top buffer of FIFO
(0234) Input : None
(0235) Output: The width of the pipe buffer
(0236) ================================================================================
(0237) */
(0238) INT8U L01_ReadTopFIFOWidth( void )
(0239) {
(0240)     INT8U btmp;
(0241)     L01_CSN_LOW( );
    004EB 98C2      CBI	0x18,2
    004EC 9ABA      SBI	0x17,2
(0242)     SPI_ExchangeByte( R_RX_PL_WID );
    004ED E600      LDI	R16,0x60
    004EE DF64      RCALL	_SPI_ExchangeByte
(0243)     btmp = SPI_ExchangeByte( 0xFF );
    004EF EF0F      LDI	R16,0xFF
    004F0 DF62      RCALL	_SPI_ExchangeByte
    004F1 2EA0      MOV	R10,R16
(0244)     L01_CSN_HIGH( );
    004F2 9AC2      SBI	0x18,2
    004F3 9ABA      SBI	0x17,2
(0245)     return btmp;
    004F4 90A9      LD	R10,Y+
    004F5 9508      RET
_L01_ReadRXPayload:
  width                --> R10
  PipeNum              --> R20
  pBuff                --> R12
    004F6 D2D9      RCALL	push_xgset30FC
    004F7 0168      MOVW	R12,R16
(0246) }
(0247) /*
(0248) ================================================================================
(0249) Function : L01_ReadRXPayload( )
(0250) Description : Read the RX payload from internal buffer
(0251) Input : -pBuff, buffer to store the data
(0252) Output: The length of data read
(0253) ================================================================================
(0254) */
(0255) INT8U L01_ReadRXPayload( INT8U *pBuff )
(0256) {
(0257)     INT8U width, PipeNum;
(0258)     PipeNum = ( L01_ReadSingleReg( L01REG_STATUS ) >> 1 ) & 0x07;
    004F8 E007      LDI	R16,7
    004F9 DF78      RCALL	_L01_ReadSingleReg
    004FA 2F40      MOV	R20,R16
    004FB 9546      LSR	R20
    004FC 7047      ANDI	R20,7
(0259)     width = L01_ReadTopFIFOWidth( );
    004FD DFEC      RCALL	_L01_ReadTopFIFOWidth
    004FE 2EA0      MOV	R10,R16
(0260) 
(0261)     L01_CSN_LOW( );
    004FF 98C2      CBI	0x18,2
    00500 9ABA      SBI	0x17,2
(0262)     SPI_ExchangeByte( R_RX_PAYLOAD );
    00501 E601      LDI	R16,0x61
    00502 DF50      RCALL	_SPI_ExchangeByte
(0263)     for( PipeNum = 0; PipeNum < width; PipeNum ++ )
    00503 2744      CLR	R20
    00504 C009      RJMP	0x050E
(0264)     {
(0265)         *( pBuff + PipeNum ) = SPI_ExchangeByte( 0xFF );
    00505 EF0F      LDI	R16,0xFF
    00506 DF4C      RCALL	_SPI_ExchangeByte
    00507 2EE0      MOV	R14,R16
    00508 2FE4      MOV	R30,R20
    00509 27FF      CLR	R31
    0050A 0DEC      ADD	R30,R12
    0050B 1DFD      ADC	R31,R13
    0050C 82E0      ST	Z,R14
    0050D 9543      INC	R20
    0050E 154A      CP	R20,R10
    0050F F3A8      BCS	0x0505
(0266)     }
(0267)     L01_CSN_HIGH( );
    00510 9AC2      SBI	0x18,2
    00511 9ABA      SBI	0x17,2
(0268)     L01_FlushRX( );
    00512 DFA3      RCALL	_L01_FlushRX
(0269)     return width;
    00513 2D0A      MOV	R16,R10
    00514 C2A5      RJMP	pop_xgset30FC
_L01_WriteTXPayload_Ack:
  length               --> R12
  btmp                 --> R10
  nBytes               --> R10
  pBuff                --> R14
    00515 D2BA      RCALL	push_xgset30FC
    00516 2EA2      MOV	R10,R18
    00517 0178      MOVW	R14,R16
(0270) }
(0271) /*
(0272) ================================================================================
(0273) Function : L01_WriteTXPayload( )
(0274) Description : Write TX payload to a pipe and prx will return ack back
(0275) Input : -PipeNum, number of the pipe
(0276)         -pBuff, A buffer stores the data
(0277)         -nBytes, How many bytes to be wrote to
(0278) Output: None
(0279) ================================================================================
(0280) */
(0281) void L01_WriteTXPayload_Ack( INT8U *pBuff, INT8U nBytes )
(0282) {
(0283)     INT8U btmp;
(0284)     INT8U length = ( nBytes > 32 ) ? 32 : nBytes;
    00518 E280      LDI	R24,0x20
    00519 158A      CP	R24,R10
    0051A F418      BCC	0x051E
    0051B E240      LDI	R20,0x20
    0051C E050      LDI	R21,0
    0051D C002      RJMP	0x0520
    0051E 2D4A      MOV	R20,R10
    0051F 2755      CLR	R21
    00520 2EC4      MOV	R12,R20
(0285) 
(0286)     L01_FlushTX( );
    00521 DF8D      RCALL	_L01_FlushTX
(0287)     L01_CSN_LOW( );
    00522 98C2      CBI	0x18,2
    00523 9ABA      SBI	0x17,2
(0288)     SPI_ExchangeByte( W_TX_PAYLOAD );
    00524 EA00      LDI	R16,0xA0
    00525 DF2D      RCALL	_SPI_ExchangeByte
(0289)     for( btmp = 0; btmp < length; btmp ++ )
    00526 24AA      CLR	R10
    00527 C007      RJMP	0x052F
(0290)     {
(0291)         SPI_ExchangeByte( *( pBuff + btmp ) );
    00528 2DEA      MOV	R30,R10
    00529 27FF      CLR	R31
    0052A 0DEE      ADD	R30,R14
    0052B 1DFF      ADC	R31,R15
    0052C 8100      LD	R16,Z
    0052D DF25      RCALL	_SPI_ExchangeByte
    0052E 94A3      INC	R10
    0052F 14AC      CP	R10,R12
    00530 F3B8      BCS	0x0528
(0292)     }
(0293)     L01_CSN_HIGH( );
    00531 9AC2      SBI	0x18,2
    00532 9ABA      SBI	0x17,2
    00533 C286      RJMP	pop_xgset30FC
_L01_WriteTXPayload_NoAck:
  Data_Length          --> R20
  Data                 --> R10
    00534 D2A4      RCALL	push_xgset300C
    00535 2F42      MOV	R20,R18
    00536 0158      MOVW	R10,R16
(0294) }
(0295) /*
(0296) ================================================================================
(0297) Function : L01_WritePayload_NoAck( )
(0298) Description : write data in tx mode, and prx won't return ack back
(0299) Input : -Data, A buffer stores the address data
(0300)         -Data_Length, How many bytes of the data buff
(0301) Output: None
(0302) ================================================================================
(0303) */
(0304) void L01_WriteTXPayload_NoAck( INT8U *Data, INT8U Data_Length )
(0305) {
(0306)     if( Data_Length > 32 || Data_Length == 0 )
    00537 E280      LDI	R24,0x20
    00538 1784      CP	R24,R20
    00539 F010      BCS	0x053C
    0053A 2344      TST	R20
    0053B F409      BNE	0x053D
(0307)     {
(0308)         return ;
    0053C C010      RJMP	0x054D
(0309)     }
(0310)     L01_CSN_LOW( );
    0053D 98C2      CBI	0x18,2
    0053E 9ABA      SBI	0x17,2
(0311)     SPI_ExchangeByte( W_TX_PAYLOAD_NOACK );
    0053F EB00      LDI	R16,0xB0
    00540 DF12      RCALL	_SPI_ExchangeByte
    00541 C004      RJMP	0x0546
(0312)     while( Data_Length-- )
(0313)     {
(0314)         SPI_ExchangeByte( *Data++ );
    00542 01F5      MOVW	R30,R10
    00543 9101      LD	R16,Z+
    00544 015F      MOVW	R10,R30
    00545 DF0D      RCALL	_SPI_ExchangeByte
    00546 2E24      MOV	R2,R20
    00547 2433      CLR	R3
    00548 5041      SUBI	R20,1
    00549 2022      TST	R2
    0054A F7B9      BNE	0x0542
(0315)     }
(0316)     L01_CSN_HIGH( );
    0054B 9AC2      SBI	0x18,2
    0054C 9ABA      SBI	0x17,2
    0054D C290      RJMP	pop_xgset300C
_L01_WriteRXPayload_InAck:
  length               --> R12
  btmp                 --> R10
  Data_Length          --> R10
  pData                --> R14
    0054E D281      RCALL	push_xgset30FC
    0054F 2EA2      MOV	R10,R18
    00550 0178      MOVW	R14,R16
(0317) }
(0318) /*
(0319) ================================================================================
(0320) Function : L01_WritePayload_InAck( )
(0321) Description : write data in tx fifo when rx mode
(0322) Input : -Data, A buffer stores the address data
(0323)         -Data_Length, How many bytes of the data buff
(0324) Output: None
(0325) ================================================================================
(0326) */
(0327) void L01_WriteRXPayload_InAck( INT8U *pData, INT8U Data_Length )
(0328) {
(0329)     INT8U length = ( Data_Length > 32 ) ? 32 : Data_Length;
    00551 E280      LDI	R24,0x20
    00552 158A      CP	R24,R10
    00553 F418      BCC	0x0557
    00554 E240      LDI	R20,0x20
    00555 E050      LDI	R21,0
    00556 C002      RJMP	0x0559
    00557 2D4A      MOV	R20,R10
    00558 2755      CLR	R21
    00559 2EC4      MOV	R12,R20
(0330)     INT8U btmp;
(0331) 
(0332)     L01_CSN_LOW( );
    0055A 98C2      CBI	0x18,2
    0055B 9ABA      SBI	0x17,2
(0333)     SPI_ExchangeByte( W_ACK_PAYLOAD );
    0055C EA08      LDI	R16,0xA8
    0055D DEF5      RCALL	_SPI_ExchangeByte
(0334)     for( btmp = 0; btmp < length; btmp ++ )
    0055E 24AA      CLR	R10
    0055F C007      RJMP	0x0567
(0335)     {
(0336)         SPI_ExchangeByte( *( pData + btmp ) );
    00560 2DEA      MOV	R30,R10
    00561 27FF      CLR	R31
    00562 0DEE      ADD	R30,R14
    00563 1DFF      ADC	R31,R15
    00564 8100      LD	R16,Z
    00565 DEED      RCALL	_SPI_ExchangeByte
    00566 94A3      INC	R10
    00567 14AC      CP	R10,R12
    00568 F3B8      BCS	0x0560
(0337)     }
(0338)     L01_CSN_HIGH( );
    00569 9AC2      SBI	0x18,2
    0056A 9ABA      SBI	0x17,2
    0056B C24E      RJMP	pop_xgset30FC
_L01_SetTXAddr:
  Length               --> R12
  Addr_Length          --> R12
  pAddr                --> R10
    0056C D284      RCALL	push_xgset303C
    0056D 2EC2      MOV	R12,R18
    0056E 0158      MOVW	R10,R16
    0056F 9721      SBIW	R28,1
(0339) }
(0340) /*
(0341) ================================================================================
(0342) Function : L01_SetTXAddr( )
(0343) Description : Write address for the own device
(0344) Input : -pAddr, A buffer stores the address data
(0345)         -Addr_Length, How many bytes of the address
(0346) Output: None
(0347) ================================================================================
(0348) */
(0349) void L01_SetTXAddr( INT8U *pAddr, INT8U Addr_Length )
(0350) {
(0351)     INT8U Length = ( Addr_Length > 5 ) ? 5 : Addr_Length;
    00570 E085      LDI	R24,5
    00571 158C      CP	R24,R12
    00572 F418      BCC	0x0576
    00573 E045      LDI	R20,5
    00574 E050      LDI	R21,0
    00575 C002      RJMP	0x0578
    00576 2D4C      MOV	R20,R12
    00577 2755      CLR	R21
    00578 2EC4      MOV	R12,R20
(0352)     L01_WriteMultiReg( L01REG_TX_ADDR, pAddr, Length );
    00579 82C8      ST	Y,R12
    0057A 0195      MOVW	R18,R10
    0057B E100      LDI	R16,0x10
    0057C DF15      RCALL	_L01_WriteMultiReg
    0057D 9621      ADIW	R28,1
    0057E C279      RJMP	pop_xgset303C
_L01_SetRXAddr:
  pipe                 --> R20
  Length               --> R12
  Addr_Length          --> R12
  pAddr                --> R10
  PipeNum              --> R14
    0057F D250      RCALL	push_xgset30FC
    00580 0159      MOVW	R10,R18
    00581 2EE0      MOV	R14,R16
    00582 9721      SBIW	R28,1
    00583 84C9      LDD	R12,Y+9
(0353) }
(0354) /*
(0355) ================================================================================
(0356) Function : L01_SetRXAddr( )
(0357) Description : Write address for a RX pipe
(0358) Input : -PipeNum, number of the pipe
(0359)         -pAddr, A buffer stores the address data
(0360)         -Addr_Length, How many bytes of the address
(0361) Output: None
(0362) ================================================================================
(0363) */
(0364) void L01_SetRXAddr( INT8U PipeNum, INT8U *pAddr, INT8U Addr_Length )
(0365) {
(0366)     INT8U Length = ( Addr_Length > 5 ) ? 5 : Addr_Length;
    00584 E085      LDI	R24,5
    00585 158C      CP	R24,R12
    00586 F418      BCC	0x058A
    00587 E045      LDI	R20,5
    00588 E050      LDI	R21,0
    00589 C002      RJMP	0x058C
    0058A 2D4C      MOV	R20,R12
    0058B 2755      CLR	R21
    0058C 2EC4      MOV	R12,R20
(0367)     INT8U pipe = ( PipeNum > 5 ) ? 5 : PipeNum;
    0058D E085      LDI	R24,5
    0058E 158E      CP	R24,R14
    0058F F418      BCC	0x0593
    00590 E045      LDI	R20,5
    00591 E050      LDI	R21,0
    00592 C002      RJMP	0x0595
    00593 2D4E      MOV	R20,R14
    00594 2755      CLR	R21
(0368) 
(0369)     L01_WriteMultiReg( L01REG_RX_ADDR_P0 + pipe, pAddr, Length );
    00595 82C8      ST	Y,R12
    00596 0195      MOVW	R18,R10
    00597 2F04      MOV	R16,R20
    00598 5F06      SUBI	R16,0xF6
    00599 DEF8      RCALL	_L01_WriteMultiReg
    0059A 9621      ADIW	R28,1
    0059B C21E      RJMP	pop_xgset30FC
_L01_SetSpeed:
  btmp                 --> R20
  speed                --> R22
    0059C 934A      ST	-Y,R20
    0059D 936A      ST	-Y,R22
    0059E 2F60      MOV	R22,R16
(0370) }
(0371) /*
(0372) ================================================================================
(0373) Function : L01_SetSpeed )
(0374) Description : Send the communication speed of the RF device
(0375) Input :    speed,
(0376) Output: None
(0377) ================================================================================
(0378) */
(0379) void L01_SetSpeed( L01SPD speed )
(0380) {
(0381) 	INT8U btmp = L01_ReadSingleReg( L01REG_RF_SETUP );
    0059F E006      LDI	R16,6
    005A0 DED1      RCALL	_L01_ReadSingleReg
    005A1 2F40      MOV	R20,R16
(0382) 
(0383) 	btmp &= ~( ( 1<<5 ) | ( 1<<3 ) );
    005A2 7D47      ANDI	R20,0xD7
(0384) 	if( speed == SPD_250K )		//250K
    005A3 2366      TST	R22
    005A4 F411      BNE	0x05A7
(0385) 	{
(0386) 		btmp |= ( 1<<5 );
    005A5 6240      ORI	R20,0x20
(0387) 	}
    005A6 C007      RJMP	0x05AE
(0388) 	else if( speed == SPD_1M )   //1M
    005A7 3061      CPI	R22,1
    005A8 F411      BNE	0x05AB
(0389) 	{
(0390)    		btmp &= ~( ( 1<<5 ) | ( 1<<3 ) );
    005A9 7D47      ANDI	R20,0xD7
(0391) 	}
    005AA C003      RJMP	0x05AE
(0392) 	else if( speed == SPD_2M )   //2M
    005AB 3062      CPI	R22,2
    005AC F409      BNE	0x05AE
(0393) 	{
(0394) 		btmp |= ( 1<<3 );
    005AD 6048      ORI	R20,0x8
(0395) 	}
(0396) 
(0397) 	L01_WriteSingleReg( L01REG_RF_SETUP, btmp );
    005AE 2F24      MOV	R18,R20
    005AF E006      LDI	R16,6
    005B0 DECE      RCALL	_L01_WriteSingleReg
    005B1 9169      LD	R22,Y+
    005B2 9149      LD	R20,Y+
    005B3 9508      RET
_L01_SetPower:
  btmp                 --> R20
  power                --> R10
    005B4 D22E      RCALL	push_xgsetF00C
    005B5 2EA0      MOV	R10,R16
(0398) }
(0399) /*
(0400) ================================================================================
(0401) Function : L01_SetPower )
(0402) Description : Send the transmitt power of the device
(0403) Input :    power
(0404) Output: None
(0405) ================================================================================
(0406) */
(0407) void L01_SetPower( L01PWR power )
(0408) {
(0409)     INT8U btmp = L01_ReadSingleReg( L01REG_RF_SETUP ) & ~0x07;
    005B6 E006      LDI	R16,6
    005B7 DEBA      RCALL	_L01_ReadSingleReg
    005B8 2F40      MOV	R20,R16
    005B9 7F48      ANDI	R20,0xF8
(0410)     switch( power )
    005BA 2D6A      MOV	R22,R10
    005BB 2777      CLR	R23
    005BC 3060      CPI	R22,0
    005BD 0767      CPC	R22,R23
    005BE F069      BEQ	0x05CC
    005BF 3061      CPI	R22,1
    005C0 E0E0      LDI	R30,0
    005C1 077E      CPC	R23,R30
    005C2 F051      BEQ	0x05CD
    005C3 3062      CPI	R22,2
    005C4 E0E0      LDI	R30,0
    005C5 077E      CPC	R23,R30
    005C6 F041      BEQ	0x05CF
    005C7 3063      CPI	R22,3
    005C8 E0E0      LDI	R30,0
    005C9 077E      CPC	R23,R30
    005CA F031      BEQ	0x05D1
    005CB C006      RJMP	0x05D2
(0411)     {
(0412)         case P_F18DBM:
(0413)             btmp |= PWR_18DB;
(0414)             break;
    005CC C005      RJMP	0x05D2
(0415)         case P_F12DBM:
(0416)             btmp |= PWR_12DB;
    005CD 6042      ORI	R20,2
(0417)             break;
    005CE C003      RJMP	0x05D2
(0418)         case P_F6DBM:
(0419)             btmp |= PWR_6DB;
    005CF 6044      ORI	R20,4
(0420)             break;
    005D0 C001      RJMP	0x05D2
(0421)         case P_0DBM:
(0422)             btmp |= PWR_0DB;
    005D1 6046      ORI	R20,6
(0423)             break;
(0424)         default:
(0425)             break;
(0426)     }
(0427)     L01_WriteSingleReg( L01REG_RF_SETUP, btmp );
    005D2 2F24      MOV	R18,R20
    005D3 E006      LDI	R16,6
    005D4 DEAA      RCALL	_L01_WriteSingleReg
    005D5 C214      RJMP	pop_xgsetF00C
_L01_WriteHoppingPoint:
  FreqPoint            --> R20
    005D6 934A      ST	-Y,R20
    005D7 2F40      MOV	R20,R16
(0428) }
(0429) /*
(0430) ================================================================================
(0431) Function : L01_WriteHoppingPoint( )
(0432) Description : Set frequency for the device,must be 0-125
(0433) Input : -FreqPoint, The hopping point
(0434) Output: None
(0435) ================================================================================
(0436) */
(0437) void L01_WriteHoppingPoint( INT8U FreqPoint )
(0438) {
(0439)     L01_WriteSingleReg( L01REG_RF_CH, FreqPoint & 0x7F );
    005D8 2F24      MOV	R18,R20
    005D9 772F      ANDI	R18,0x7F
    005DA E005      LDI	R16,5
    005DB DEA3      RCALL	_L01_WriteSingleReg
    005DC 9149      LD	R20,Y+
    005DD 9508      RET
(0440) }
(0441) /*
(0442) ================================================================================
(0443) Function : L01_IsTXEmpty( )
(0444) Description : Check the TX FIFO if is empty,1:empty, 0:not empty
(0445) Input : -FreqPoint, The hopping point
(0446) Output: 1:empty, 0:not empty
(0447) ================================================================================
(0448) */
(0449) INT8U L01_IsTXEmpty( void )
(0450) {
(0451) 	return L01_ReadSingleReg( L01REG_FIFO_STATUS ) & ( 1<<TX_EMPTY );
_L01_IsTXEmpty:
    005DE E107      LDI	R16,0x17
    005DF DE92      RCALL	_L01_ReadSingleReg
    005E0 7100      ANDI	R16,0x10
    005E1 9508      RET
_L01_SetTRMode:
  controlreg           --> R20
  mode                 --> R22
    005E2 934A      ST	-Y,R20
    005E3 936A      ST	-Y,R22
    005E4 2F60      MOV	R22,R16
(0452) }
(0453) 
(0454) /*
(0455) ================================================================================
(0456) Function : L01_SetTRMode( )
(0457) Description : Set the device as TX or RX mode
(0458) Input : -mode, the mode to be set
(0459)             @TX_MODE, TX mode
(0460)             @RX_MODE, RX mode
(0461) Output: None
(0462) ================================================================================
(0463) */
(0464) void L01_SetTRMode( L01MD mode )
(0465) {
(0466)     INT8U controlreg = L01_ReadSingleReg( L01REG_CONFIG );
    005E5 2700      CLR	R16
    005E6 DE8B      RCALL	_L01_ReadSingleReg
    005E7 2F40      MOV	R20,R16
(0467)     if( mode == TX_MODE )       { controlreg &= ~( 1<<PRIM_RX ); L01_SetCE( 0 ); }
    005E8 2366      TST	R22
    005E9 F421      BNE	0x05EE
    005EA 7F4E      ANDI	R20,0xFE
    005EB 2700      CLR	R16
    005EC DE7B      RCALL	_L01_SetCE
    005ED C005      RJMP	0x05F3
(0468)     else if( mode == RX_MODE )  { controlreg |= ( 1<<PRIM_RX ); L01_SetCE( 1 );}
    005EE 3061      CPI	R22,1
    005EF F419      BNE	0x05F3
    005F0 6041      ORI	R20,1
    005F1 E001      LDI	R16,1
    005F2 DE75      RCALL	_L01_SetCE
(0469) 
(0470)     L01_WriteSingleReg( L01REG_CONFIG, controlreg );
    005F3 2F24      MOV	R18,R20
    005F4 2700      CLR	R16
    005F5 DE89      RCALL	_L01_WriteSingleReg
    005F6 9169      LD	R22,Y+
    005F7 9149      LD	R20,Y+
    005F8 9508      RET
_L01_SetPowerDown:
  controlreg           --> R20
    005F9 934A      ST	-Y,R20
(0471) }
(0472) /*
(0473) ================================================================================
(0474) Function : L01_SetPowerDown( )
(0475) Description : Set the nRF24L01 into PowerDown mode
(0476) Input : None
(0477) Output: None
(0478) ================================================================================
(0479) */
(0480) void L01_SetPowerDown( void )
(0481) {
(0482) 	INT8U controlreg = L01_ReadSingleReg( L01REG_CONFIG );
    005FA 2700      CLR	R16
    005FB DE76      RCALL	_L01_ReadSingleReg
    005FC 2F40      MOV	R20,R16
(0483)     L01_WriteSingleReg( L01REG_CONFIG, controlreg & ( ~( 1<<PWR_UP ) ) );
    005FD 2F24      MOV	R18,R20
    005FE 7F2D      ANDI	R18,0xFD
    005FF 2700      CLR	R16
    00600 DE7E      RCALL	_L01_WriteSingleReg
    00601 9149      LD	R20,Y+
    00602 9508      RET
_L01_SetPowerUp:
  controlreg           --> R20
    00603 934A      ST	-Y,R20
(0484) }
(0485) /*
(0486) ================================================================================
(0487) Function : L01_SetPowerUp( )
(0488) Description : Set the nRF24L01 into Powerup mode
(0489) Input : None
(0490) Output: None
(0491) ================================================================================
(0492) */
(0493) void L01_SetPowerUp( void )
(0494) {
(0495) 	INT8U controlreg = L01_ReadSingleReg( L01REG_CONFIG );
    00604 2700      CLR	R16
    00605 DE6C      RCALL	_L01_ReadSingleReg
    00606 2F40      MOV	R20,R16
(0496)     L01_WriteSingleReg( L01REG_CONFIG, controlreg | ( 1<<PWR_UP ) );
    00607 2F24      MOV	R18,R20
    00608 6022      ORI	R18,2
    00609 2700      CLR	R16
    0060A DE74      RCALL	_L01_WriteSingleReg
    0060B 9149      LD	R20,Y+
    0060C 9508      RET
_L01_Init:
  tmp                  --> R10
  addr                 --> Y,+1
    0060D 92AA      ST	-Y,R10
    0060E 9726      SBIW	R28,6
(0497) }
(0498) /*
(0499) ================================================================================
(0500) Function : L01_Init( )
(0501) Description : Initialize the nRF24L01
(0502) Input : None
(0503) Output: None
(0504) ================================================================================
(0505) */
(0506) void L01_Init( void )
(0507) {
(0508)     INT8U addr[5] = {INIT_ADDR};
    0060F E380      LDI	R24,0x30
    00610 E090      LDI	R25,0
    00611 01FE      MOVW	R30,R28
    00612 9631      ADIW	R30,1
    00613 E005      LDI	R16,5
    00614 E010      LDI	R17,0
    00615 93FA      ST	-Y,R31
    00616 93EA      ST	-Y,R30
    00617 939A      ST	-Y,R25
    00618 938A      ST	-Y,R24
    00619 D1F7      RCALL	asgncblk
(0509) 
(0510) 	INT8U tmp = L01_GetCEStatus( );
    0061A DE4A      RCALL	_L01_GetCEStatus
    0061B 2EA0      MOV	R10,R16
(0511)     L01_SetCE( 0 );
    0061C 2700      CLR	R16
    0061D DE4A      RCALL	_L01_SetCE
(0512) 	L01_SetPowerDown( );
    0061E DFDA      RCALL	_L01_SetPowerDown
(0513)     L01_ClearIRQ( IRQ_ALL );
    0061F E700      LDI	R16,0x70
    00620 DEB4      RCALL	_L01_ClearIRQ
(0514) #if DYNAMIC_PACKET == 1
(0515)     //dynamic payload length
(0516)     L01_WriteSingleReg( L01REG_DYNPD, ( 1<<0 ) );//Enable pipe 0 dynamic payload length
    00621 E021      LDI	R18,1
    00622 E10C      LDI	R16,0x1C
    00623 DE5B      RCALL	_L01_WriteSingleReg
(0517)     L01_WriteSingleReg( L01REG_FEATRUE, 0x06 );
    00624 E026      LDI	R18,6
    00625 E10D      LDI	R16,0x1D
    00626 DE58      RCALL	_L01_WriteSingleReg
(0518)     L01_ReadSingleReg( L01REG_DYNPD );
    00627 E10C      LDI	R16,0x1C
    00628 DE49      RCALL	_L01_ReadSingleReg
(0519)     L01_ReadSingleReg( L01REG_FEATRUE );
    00629 E10D      LDI	R16,0x1D
    0062A DE47      RCALL	_L01_ReadSingleReg
(0520) #elif DYNAMIC_PACKET == 0
(0521)     //Fixed packet length
(0522)     L01_WriteSingleReg( L01REG_RX_PW_P0, FIXED_PACKET_LEN );
(0523) #endif//DYNAMIC_PACKET
(0524) 
(0525)     L01_WriteSingleReg( L01REG_CONFIG,/* ( 1<<MASK_TX_DS ) |*////receive interrupt
    0062B E028      LDI	R18,0x8
    0062C 2700      CLR	R16
    0062D DE51      RCALL	_L01_WriteSingleReg
(0526)                                       ( 1<<EN_CRC ) );     //Enable CRC, 1 byte
(0527)     L01_WriteSingleReg( L01REG_EN_AA, ( 1<<ENAA_P0 ) );   //Auto ack in pipe 0
    0062E E021      LDI	R18,1
    0062F E001      LDI	R16,1
    00630 DE4E      RCALL	_L01_WriteSingleReg
(0528)     L01_WriteSingleReg( L01REG_EN_RXADDR, ( 1<<ERX_P0 ) );//Enable pipe 0 receive
    00631 E021      LDI	R18,1
    00632 E002      LDI	R16,2
    00633 DE4B      RCALL	_L01_WriteSingleReg
(0529)     L01_WriteSingleReg( L01REG_SETUP_AW, AW_5BYTES );     //Address width : 5Byte
    00634 E023      LDI	R18,3
    00635 E003      LDI	R16,3
    00636 DE48      RCALL	_L01_WriteSingleReg
(0530)     L01_WriteSingleReg( L01REG_RETR, (((REPEAT_TIME/250)&0X0F)<<4) |
    00637 E82F      LDI	R18,0x8F
    00638 E004      LDI	R16,4
    00639 DE45      RCALL	_L01_WriteSingleReg
(0531)                         ( REPEAT_CNT & 0x0F ) );          //repeat SETTING
(0532)     L01_WriteSingleReg( L01REG_RF_CH, 0x0 );             //Initial channel
    0063A 2722      CLR	R18
    0063B E005      LDI	R16,5
    0063C DE42      RCALL	_L01_WriteSingleReg
(0533)     L01_WriteSingleReg( L01REG_RF_SETUP, 0x27 );
    0063D E227      LDI	R18,0x27
    0063E E006      LDI	R16,6
    0063F DE3F      RCALL	_L01_WriteSingleReg
(0534)     L01_SetTXAddr( &addr[0], 5 );                          //Set TX address
    00640 E025      LDI	R18,5
    00641 018E      MOVW	R16,R28
    00642 5F0F      SUBI	R16,0xFF
    00643 4F1F      SBCI	R17,0xFF
    00644 DF27      RCALL	_L01_SetTXAddr
(0535)     L01_SetRXAddr( 0, &addr[0], 5 );                       //Set RX address
    00645 E085      LDI	R24,5
    00646 8388      ST	Y,R24
    00647 019E      MOVW	R18,R28
    00648 5F2F      SUBI	R18,0xFF
    00649 4F3F      SBCI	R19,0xFF
    0064A 2700      CLR	R16
    0064B DF33      RCALL	_L01_SetRXAddr
(0536) 	L01_SetPowerUp( );
    0064C DFB6      RCALL	_L01_SetPowerUp
    0064D 9626      ADIW	R28,6
    0064E 90A9      LD	R10,Y+
    0064F 9508      RET
_LCD_Dis_16x16:
  i                    --> R20
  p_data               --> R22
  column               --> R12
  page                 --> R10
    00650 D1AE      RCALL	push_xgsetF03C
    00651 2EC2      MOV	R12,R18
    00652 2EA0      MOV	R10,R16
    00653 8568      LDD	R22,Y+8
    00654 8579      LDD	R23,Y+9
FILE: F:\产品\ODMPRO~1\E06-RFTB\E06-AVR\DEMO_AVR\nRF24L01P\Source\OLED.c
(0001) 
(0002) #include "OLED.h"
(0003) #include "font.h"
(0004) 
(0005) /*Write a command to OLED module*/
(0006) void LCD_WrCmd(INT8U cmd);
(0007) 
(0008) /*Write a byte to OLED module*/
(0009) void LCD_WrDat(INT8U dt);
(0010) 
(0011) /*Set the position of the OLED*/
(0012) void LCD_Set_Pos( INT8U page, INT8U column );
(0013) 
(0014) 
(0015) /*
(0016) =================================================================================
(0017) LCD_Dis_16x16( );
(0018) Function : Display 16x16
(0019) INTPUT   : page, the page of the LCD, 0-7
(0020)            column, the column of the LCD, 0-127
(0021)            p_data, the data array for display
(0022) OUTPUT   : None
(0023) =================================================================================
(0024) */
(0025) void LCD_Dis_16x16( INT8U page, INT8U column, const INT8U *p_data )
(0026) {
(0027)     INT8U i;
(0028) 
(0029)     LCD_Set_Pos( page, column );
    00655 2D2C      MOV	R18,R12
    00656 2D0A      MOV	R16,R10
    00657 D064      RCALL	_LCD_Set_Pos
(0030)     for( i = 0; i < 16; i ++ )
    00658 2744      CLR	R20
    00659 C007      RJMP	0x0661
(0031)     {
(0032)         LCD_WrDat( *p_data ++ );
    0065A 011B      MOVW	R2,R22
    0065B 5F6F      SUBI	R22,0xFF
    0065C 4F7F      SBCI	R23,0xFF
    0065D 01F1      MOVW	R30,R2
    0065E 9104      LPM	R16,Z
    0065F D0C4      RCALL	_LCD_WrDat
    00660 9543      INC	R20
    00661 3140      CPI	R20,0x10
    00662 F3B8      BCS	0x065A
(0033)     }
(0034)     LCD_Set_Pos( page+1, column );
    00663 2D2C      MOV	R18,R12
    00664 2D0A      MOV	R16,R10
    00665 5F0F      SUBI	R16,0xFF
    00666 D055      RCALL	_LCD_Set_Pos
(0035)     for( i = 0; i < 16; i ++ )
    00667 2744      CLR	R20
    00668 C007      RJMP	0x0670
(0036)     {
(0037)         LCD_WrDat( *p_data ++ );
    00669 011B      MOVW	R2,R22
    0066A 5F6F      SUBI	R22,0xFF
    0066B 4F7F      SBCI	R23,0xFF
    0066C 01F1      MOVW	R30,R2
    0066D 9104      LPM	R16,Z
    0066E D0B5      RCALL	_LCD_WrDat
    0066F 9543      INC	R20
    00670 3140      CPI	R20,0x10
    00671 F3B8      BCS	0x0669
    00672 C195      RJMP	pop_xgsetF03C
_LCD_Dis_Logo:
  i                    --> R10
    00673 92AA      ST	-Y,R10
    00674 9722      SBIW	R28,2
(0038)     }
(0039) 
(0040) }
(0041) /*
(0042) =================================================================================
(0043) LCD_Dis_Logo( );
(0044) Function : Display the manufacture LOGO
(0045) INTPUT   : None
(0046) OUTPUT   : None
(0047) =================================================================================
(0048) */
(0049) void LCD_Dis_Logo( void )
(0050) {
(0051)     INT8U i = 0;
    00675 24AA      CLR	R10
(0052)     LCD_Dis_16x16( 0, i*16+32, &Our_Logo[32*i] );
    00676 E200      LDI	R16,0x20
    00677 2D1A      MOV	R17,R10
    00678 0301      MULSU	R16,R17
    00679 0110      MOVW	R2,R0
    0067A E285      LDI	R24,0x25
    0067B E096      LDI	R25,6
    0067C 0E28      ADD	R2,R24
    0067D 1E39      ADC	R3,R25
    0067E 8239      STD	Y+1,R3
    0067F 8228      ST	Y,R2
    00680 E100      LDI	R16,0x10
    00681 0301      MULSU	R16,R17
    00682 2D20      MOV	R18,R0
    00683 5E20      SUBI	R18,0xE0
    00684 2700      CLR	R16
    00685 DFCA      RCALL	_LCD_Dis_16x16
(0053)     i++;
    00686 94A3      INC	R10
(0054)     LCD_Dis_16x16( 0, i*16+32, &Our_Logo[32*i] );
    00687 E200      LDI	R16,0x20
    00688 2D1A      MOV	R17,R10
    00689 0301      MULSU	R16,R17
    0068A 0110      MOVW	R2,R0
    0068B E285      LDI	R24,0x25
    0068C E096      LDI	R25,6
    0068D 0E28      ADD	R2,R24
    0068E 1E39      ADC	R3,R25
    0068F 8239      STD	Y+1,R3
    00690 8228      ST	Y,R2
    00691 E100      LDI	R16,0x10
    00692 0301      MULSU	R16,R17
    00693 2D20      MOV	R18,R0
    00694 5E20      SUBI	R18,0xE0
    00695 2700      CLR	R16
    00696 DFB9      RCALL	_LCD_Dis_16x16
(0055)     i++;
    00697 94A3      INC	R10
(0056)     LCD_Dis_16x16( 0, i*16+32, &Our_Logo[32*i] );
    00698 E200      LDI	R16,0x20
    00699 2D1A      MOV	R17,R10
    0069A 0301      MULSU	R16,R17
    0069B 0110      MOVW	R2,R0
    0069C E285      LDI	R24,0x25
    0069D E096      LDI	R25,6
    0069E 0E28      ADD	R2,R24
    0069F 1E39      ADC	R3,R25
    006A0 8239      STD	Y+1,R3
    006A1 8228      ST	Y,R2
    006A2 E100      LDI	R16,0x10
    006A3 0301      MULSU	R16,R17
    006A4 2D20      MOV	R18,R0
    006A5 5E20      SUBI	R18,0xE0
    006A6 2700      CLR	R16
    006A7 DFA8      RCALL	_LCD_Dis_16x16
(0057)     i++;
    006A8 94A3      INC	R10
(0058)     LCD_Dis_16x16( 0, i*16+32, &Our_Logo[32*i] );
    006A9 E200      LDI	R16,0x20
    006AA 2D1A      MOV	R17,R10
    006AB 0301      MULSU	R16,R17
    006AC 0110      MOVW	R2,R0
    006AD E285      LDI	R24,0x25
    006AE E096      LDI	R25,6
    006AF 0E28      ADD	R2,R24
    006B0 1E39      ADC	R3,R25
    006B1 8239      STD	Y+1,R3
    006B2 8228      ST	Y,R2
    006B3 E100      LDI	R16,0x10
    006B4 0301      MULSU	R16,R17
    006B5 2D20      MOV	R18,R0
    006B6 5E20      SUBI	R18,0xE0
    006B7 2700      CLR	R16
    006B8 DF97      RCALL	_LCD_Dis_16x16
    006B9 9622      ADIW	R28,2
    006BA 90A9      LD	R10,Y+
    006BB 9508      RET
_LCD_Set_Pos:
  column               --> R20
  page                 --> R22
    006BC 934A      ST	-Y,R20
    006BD 936A      ST	-Y,R22
    006BE 2F42      MOV	R20,R18
    006BF 2F60      MOV	R22,R16
(0059) }
(0060) /*
(0061) =================================================================================
(0062) LCD_Set_Pos( );
(0063) Function : Set the position of the OLED
(0064) INTPUT   : page, 0-7
(0065)            column, 0-128
(0066) OUTPUT   : None
(0067) =================================================================================
(0068) */
(0069) void LCD_Set_Pos( INT8U page, INT8U column )
(0070) {
(0071)     LCD_WrCmd( 0xb0 + ( page & 0x07 ) );
    006C0 2F06      MOV	R16,R22
    006C1 7007      ANDI	R16,7
    006C2 5500      SUBI	R16,0x50
    006C3 D054      RCALL	_LCD_WrCmd
(0072)     LCD_WrCmd( 0x10 + ( ( column>>4 ) & 0x0F ) );
    006C4 2F04      MOV	R16,R20
    006C5 9502      SWAP	R16
    006C6 700F      ANDI	R16,0xF
    006C7 700F      ANDI	R16,0xF
    006C8 5F00      SUBI	R16,0xF0
    006C9 D04E      RCALL	_LCD_WrCmd
(0073)     LCD_WrCmd( column & 0x0F );
    006CA 2F04      MOV	R16,R20
    006CB 700F      ANDI	R16,0xF
    006CC D04B      RCALL	_LCD_WrCmd
    006CD 9169      LD	R22,Y+
    006CE 9149      LD	R20,Y+
    006CF 9508      RET
_LCD_Dis_Char:
  pos                  --> R22
  j                    --> R20
  ch                   --> R20
  column               --> R12
  page                 --> R10
    006D0 D12E      RCALL	push_xgsetF03C
    006D1 2EC2      MOV	R12,R18
    006D2 2EA0      MOV	R10,R16
    006D3 8548      LDD	R20,Y+8
(0074) }
(0075) /*
(0076) =================================================================================
(0077) LCD_Dis_Str( );
(0078) Function : Display a character
(0079) INTPUT   : page, 0-7
(0080)            column, 0-128
(0081)            ch, the character to be displayed
(0082) OUTPUT   : None
(0083) =================================================================================
(0084) */
(0085) void LCD_Dis_Char( INT8U page, INT8U column, char ch )
(0086) {
(0087)     INT16U pos;
(0088)     INT8U j;
(0089)     if( ch < ' ' )  { return; }
    006D4 3240      CPI	R20,0x20
    006D5 F408      BCC	0x06D7
    006D6 C02B      RJMP	0x0702
(0090) 
(0091)     pos = 16*( ch - ' ' );
    006D7 E100      LDI	R16,0x10
    006D8 2F14      MOV	R17,R20
    006D9 0301      MULSU	R16,R17
    006DA 01B0      MOVW	R22,R0
    006DB 5060      SUBI	R22,0
    006DC 4072      SBCI	R23,2
(0092)     LCD_Set_Pos( page, column );
    006DD 2D2C      MOV	R18,R12
    006DE 2D0A      MOV	R16,R10
    006DF DFDC      RCALL	_LCD_Set_Pos
(0093) 
(0094)     for( j = 0; j < 8; j ++ )
    006E0 2744      CLR	R20
    006E1 C00B      RJMP	0x06ED
(0095)     {
(0096)         LCD_WrDat( Font8x16[ pos++ ] );
    006E2 011B      MOVW	R2,R22
    006E3 5F6F      SUBI	R22,0xFF
    006E4 4F7F      SBCI	R23,0xFF
    006E5 E385      LDI	R24,0x35
    006E6 E090      LDI	R25,0
    006E7 01F1      MOVW	R30,R2
    006E8 0FE8      ADD	R30,R24
    006E9 1FF9      ADC	R31,R25
    006EA 9104      LPM	R16,Z
    006EB D038      RCALL	_LCD_WrDat
    006EC 9543      INC	R20
    006ED 3048      CPI	R20,0x8
    006EE F398      BCS	0x06E2
(0097)     }
(0098)     LCD_Set_Pos( page+1, column );
    006EF 2D2C      MOV	R18,R12
    006F0 2D0A      MOV	R16,R10
    006F1 5F0F      SUBI	R16,0xFF
    006F2 DFC9      RCALL	_LCD_Set_Pos
(0099)     for( j = 0; j < 8; j ++ )
    006F3 2744      CLR	R20
    006F4 C00B      RJMP	0x0700
(0100)     {
(0101)         LCD_WrDat( Font8x16[ pos++ ] );
    006F5 011B      MOVW	R2,R22
    006F6 5F6F      SUBI	R22,0xFF
    006F7 4F7F      SBCI	R23,0xFF
    006F8 E385      LDI	R24,0x35
    006F9 E090      LDI	R25,0
    006FA 01F1      MOVW	R30,R2
    006FB 0FE8      ADD	R30,R24
    006FC 1FF9      ADC	R31,R25
    006FD 9104      LPM	R16,Z
    006FE D025      RCALL	_LCD_WrDat
    006FF 9543      INC	R20
    00700 3048      CPI	R20,0x8
    00701 F398      BCS	0x06F5
    00702 C105      RJMP	pop_xgsetF03C
_LCD_Dis_Str:
  str                  --> R10
  column               --> R20
  page                 --> R12
    00703 D0ED      RCALL	push_xgset303C
    00704 2F42      MOV	R20,R18
    00705 2EC0      MOV	R12,R16
    00706 9721      SBIW	R28,1
    00707 80AF      LDD	R10,Y+7
    00708 84B8      LDD	R11,Y+8
(0102)     }
(0103) }
(0104) /*
(0105) =================================================================================
(0106) LCD_Dis_Str( );
(0107) Function : Display a string
(0108) INTPUT   : page, 0-7
(0109)            column, 0-128
(0110)            str, the string to be displayed
(0111) OUTPUT   : None
(0112) =================================================================================
(0113) */
(0114) void LCD_Dis_Str( INT8U page, INT8U column, char *str )
(0115) {
    00709 C008      RJMP	0x0712
(0116)     while( *str )
(0117)     {
(0118)         LCD_Dis_Char( page, column, *str++ );
    0070A 01F5      MOVW	R30,R10
    0070B 9021      LD	R2,Z+
    0070C 015F      MOVW	R10,R30
    0070D 8228      ST	Y,R2
    0070E 2F24      MOV	R18,R20
    0070F 2D0C      MOV	R16,R12
    00710 DFBF      RCALL	_LCD_Dis_Char
(0119)         column += 8;
    00711 5F48      SUBI	R20,0xF8
    00712 01F5      MOVW	R30,R10
    00713 8020      LD	R2,Z
    00714 2022      TST	R2
    00715 F7A1      BNE	0x070A
    00716 9621      ADIW	R28,1
    00717 C0E0      RJMP	pop_xgset303C
_LCD_WrCmd:
  i                    --> Y,+1
  cmd                  --> R10
    00718 92AA      ST	-Y,R10
    00719 2EA0      MOV	R10,R16
(0120)     }
(0121) }
(0122) /*
(0123) =================================================================================
(0124) LCD_WrCmd( );
(0125) Function : Write a command to OLED module
(0126) INTPUT   : cmd, the command byte
(0127) OUTPUT   : None
(0128) =================================================================================
(0129) */
(0130) void LCD_WrCmd(INT8U cmd)
(0131) {
(0132)     unsigned char i;
(0133)     OLED_CSN_L( );
    0071A 98C1      CBI	0x18,1
    0071B 9AB9      SBI	0x17,1
(0134)     OLED_CMD_L( );//LCD_DC=0;
    0071C 9897      CBI	0x12,7
    0071D 9A8F      SBI	0x11,7
(0135)     SPI_ExchangeByte( cmd );
    0071E 2D0A      MOV	R16,R10
    0071F DD33      RCALL	_SPI_ExchangeByte
(0136)     OLED_CSN_H( );
    00720 9AC1      SBI	0x18,1
    00721 9AB9      SBI	0x17,1
    00722 90A9      LD	R10,Y+
    00723 9508      RET
_LCD_WrDat:
  i                    --> Y,+1
  dt                   --> R10
    00724 92AA      ST	-Y,R10
    00725 2EA0      MOV	R10,R16
(0137) }
(0138) /*
(0139) =================================================================================
(0140) LCD_WrDat( );
(0141) Function : Write a byte to OLED module
(0142) INTPUT   : dt, the data byte
(0143) OUTPUT   : None
(0144) =================================================================================
(0145) */
(0146) void LCD_WrDat(INT8U dt)
(0147) {
(0148)     unsigned char i;
(0149)     OLED_CSN_L( );
    00726 98C1      CBI	0x18,1
    00727 9AB9      SBI	0x17,1
(0150)     OLED_CMD_H( );//LCD_DC=1;
    00728 9A97      SBI	0x12,7
    00729 9A8F      SBI	0x11,7
(0151)     SPI_ExchangeByte( dt );
    0072A 2D0A      MOV	R16,R10
    0072B DD27      RCALL	_SPI_ExchangeByte
(0152)     OLED_CSN_H( );
    0072C 9AC1      SBI	0x18,1
    0072D 9AB9      SBI	0x17,1
    0072E 90A9      LD	R10,Y+
    0072F 9508      RET
_LCD_Fill:
  y                    --> R20
  x                    --> R22
  bmp_dat              --> R10
    00730 D0B2      RCALL	push_xgsetF00C
    00731 2EA0      MOV	R10,R16
(0153) }
(0154) /*
(0155) =================================================================================
(0156) LCD_Fill( );
(0157) Function : flush the whole screen
(0158) INTPUT   : bmp_dat, the data value
(0159) OUTPUT   : None
(0160) =================================================================================
(0161) */
(0162) void LCD_Fill(INT8U bmp_dat)
(0163) {
(0164)     INT8U y,x;
(0165)     for(y=0;y<8;y++)
    00732 2744      CLR	R20
    00733 C00F      RJMP	0x0743
(0166)     {
(0167)         LCD_WrCmd(0xb0+y);
    00734 2F04      MOV	R16,R20
    00735 5500      SUBI	R16,0x50
    00736 DFE1      RCALL	_LCD_WrCmd
(0168)         LCD_WrCmd(0x01);
    00737 E001      LDI	R16,1
    00738 DFDF      RCALL	_LCD_WrCmd
(0169)         LCD_WrCmd(0x10);
    00739 E100      LDI	R16,0x10
    0073A DFDD      RCALL	_LCD_WrCmd
(0170)         for(x=0;x<128;x++)
    0073B 2766      CLR	R22
    0073C C003      RJMP	0x0740
(0171)         LCD_WrDat(bmp_dat);
    0073D 2D0A      MOV	R16,R10
    0073E DFE5      RCALL	_LCD_WrDat
    0073F 9563      INC	R22
    00740 3860      CPI	R22,0x80
    00741 F3D8      BCS	0x073D
    00742 9543      INC	R20
    00743 3048      CPI	R20,0x8
    00744 F378      BCS	0x0734
    00745 C0A4      RJMP	pop_xgsetF00C
_LCD_Init:
  x                    --> R20
    00746 934A      ST	-Y,R20
    00747 935A      ST	-Y,R21
(0172)     }
(0173) }
(0174) /*
(0175) =================================================================================
(0176) LCD_Init( );
(0177) Function : Initialize the OLED module
(0178) INTPUT   : none
(0179) OUTPUT   : None
(0180) =================================================================================
(0181) */
(0182) void LCD_Init(void)
(0183) {
(0184)     INT16U x;
(0185)     OLED_RST_L() ;//LCD_RST=0;
    00748 9896      CBI	0x12,6
    00749 9A8E      SBI	0x11,6
(0186)     for( x = 0; x < 1000; x ++ );
    0074A 2744      CLR	R20
    0074B 2755      CLR	R21
    0074C C002      RJMP	0x074F
    0074D 5F4F      SUBI	R20,0xFF
    0074E 4F5F      SBCI	R21,0xFF
    0074F 3E48      CPI	R20,0xE8
    00750 E0E3      LDI	R30,3
    00751 075E      CPC	R21,R30
    00752 F3D0      BCS	0x074D
(0187)     OLED_RST_H( );//LCD_RST=1;       //从上电到下面开始初始化要有足够的时间，即等待RC复位完毕
    00753 9A96      SBI	0x12,6
    00754 9A8E      SBI	0x11,6
(0188)     LCD_WrCmd(0xae);//--turn off oled panel
    00755 EA0E      LDI	R16,0xAE
    00756 DFC1      RCALL	_LCD_WrCmd
(0189)     LCD_WrCmd(0x00);//---set low column address
    00757 2700      CLR	R16
    00758 DFBF      RCALL	_LCD_WrCmd
(0190)     LCD_WrCmd(0x10);//---set high column address
    00759 E100      LDI	R16,0x10
    0075A DFBD      RCALL	_LCD_WrCmd
(0191)     LCD_WrCmd(0x40);//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)
    0075B E400      LDI	R16,0x40
    0075C DFBB      RCALL	_LCD_WrCmd
(0192)     LCD_WrCmd(0x81);//--set contrast control register
    0075D E801      LDI	R16,0x81
    0075E DFB9      RCALL	_LCD_WrCmd
(0193)     LCD_WrCmd(0xcf); // Set SEG Output Current Brightness
    0075F EC0F      LDI	R16,0xCF
    00760 DFB7      RCALL	_LCD_WrCmd
(0194)     LCD_WrCmd(0xa1);//--Set SEG/Column Mapping     0xa0左右反置 0xa1正常
    00761 EA01      LDI	R16,0xA1
    00762 DFB5      RCALL	_LCD_WrCmd
(0195)     LCD_WrCmd(0xc8);//Set COM/Row Scan Direction   0xc0上下反置 0xc8正常
    00763 EC08      LDI	R16,0xC8
    00764 DFB3      RCALL	_LCD_WrCmd
(0196)     LCD_WrCmd(0xa6);//--set normal display
    00765 EA06      LDI	R16,0xA6
    00766 DFB1      RCALL	_LCD_WrCmd
(0197)     LCD_WrCmd(0xa8);//--set multiplex ratio(1 to 64)
    00767 EA08      LDI	R16,0xA8
    00768 DFAF      RCALL	_LCD_WrCmd
(0198)     LCD_WrCmd(0x3f);//--1/64 duty
    00769 E30F      LDI	R16,0x3F
    0076A DFAD      RCALL	_LCD_WrCmd
(0199)     LCD_WrCmd(0xd3);//-set display offset	Shift Mapping RAM Counter (0x00~0x3F)
    0076B ED03      LDI	R16,0xD3
    0076C DFAB      RCALL	_LCD_WrCmd
(0200)     LCD_WrCmd(0x00);//-not offset
    0076D 2700      CLR	R16
    0076E DFA9      RCALL	_LCD_WrCmd
(0201)     LCD_WrCmd(0xd5);//--set display clock divide ratio/oscillator frequency
    0076F ED05      LDI	R16,0xD5
    00770 DFA7      RCALL	_LCD_WrCmd
(0202)     LCD_WrCmd(0x80);//--set divide ratio, Set Clock as 100 Frames/Sec
    00771 E800      LDI	R16,0x80
    00772 DFA5      RCALL	_LCD_WrCmd
(0203)     LCD_WrCmd(0xd9);//--set pre-charge period
    00773 ED09      LDI	R16,0xD9
    00774 DFA3      RCALL	_LCD_WrCmd
(0204)     LCD_WrCmd(0xf1);//Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
    00775 EF01      LDI	R16,0xF1
    00776 DFA1      RCALL	_LCD_WrCmd
(0205)     LCD_WrCmd(0xda);//--set com pins hardware configuration
    00777 ED0A      LDI	R16,0xDA
    00778 DF9F      RCALL	_LCD_WrCmd
(0206)     LCD_WrCmd(0x12);
    00779 E102      LDI	R16,0x12
    0077A DF9D      RCALL	_LCD_WrCmd
(0207)     LCD_WrCmd(0xdb);//--set vcomh
    0077B ED0B      LDI	R16,0xDB
    0077C DF9B      RCALL	_LCD_WrCmd
(0208)     LCD_WrCmd(0x40);//Set VCOM Deselect Level
    0077D E400      LDI	R16,0x40
    0077E DF99      RCALL	_LCD_WrCmd
(0209)     LCD_WrCmd(0x20);//-Set Page Addressing Mode (0x00/0x01/0x02)
    0077F E200      LDI	R16,0x20
    00780 DF97      RCALL	_LCD_WrCmd
(0210)     LCD_WrCmd(0x02);//
    00781 E002      LDI	R16,2
    00782 DF95      RCALL	_LCD_WrCmd
(0211)     LCD_WrCmd(0x8d);//--set Charge Pump enable/disable
    00783 E80D      LDI	R16,0x8D
    00784 DF93      RCALL	_LCD_WrCmd
(0212)     LCD_WrCmd(0x14);//--set(0x10) disable
    00785 E104      LDI	R16,0x14
    00786 DF91      RCALL	_LCD_WrCmd
(0213)     LCD_WrCmd(0xa4);// Disable Entire Display On (0xa4/0xa5)
    00787 EA04      LDI	R16,0xA4
    00788 DF8F      RCALL	_LCD_WrCmd
(0214)     LCD_WrCmd(0xa6);// Disable Inverse Display On (0xa6/a7)
    00789 EA06      LDI	R16,0xA6
    0078A DF8D      RCALL	_LCD_WrCmd
(0215)     LCD_WrCmd(0xaf);//--turn on oled panel
    0078B EA0F      LDI	R16,0xAF
    0078C DF8B      RCALL	_LCD_WrCmd
(0216)     LCD_Fill(0x00);  //初始清屏
FILE: <library>
    0078D 2700      CLR	R16
    0078E DFA1      RCALL	_LCD_Fill
    0078F 9159      LD	R21,Y+
    00790 9149      LD	R20,Y+
    00791 9508      RET
_strlen:
    00792 2FE0      MOV	R30,R16
    00793 2FF1      MOV	R31,R17
    00794 27AA      CLR	R26
    00795 27BB      CLR	R27
    00796 9001      LD	R0,Z+
    00797 2000      TST	R0
    00798 F011      BEQ	0x079B
    00799 9611      ADIW	R26,1
    0079A CFFB      RJMP	0x0796
    0079B 2F0A      MOV	R16,R26
    0079C 2F1B      MOV	R17,R27
    0079D 9508      RET
mod16u:
    0079E 9468      BSET	6
    0079F C001      RJMP	xdiv16u
div16u:
    007A0 94E8      BCLR	6
xdiv16u:
    007A1 92EA      ST	-Y,R14
    007A2 92FA      ST	-Y,R15
    007A3 938A      ST	-Y,R24
    007A4 24EE      CLR	R14
    007A5 24FF      CLR	R15
    007A6 E180      LDI	R24,0x10
    007A7 0F00      LSL	R16
    007A8 1F11      ROL	R17
    007A9 1CEE      ROL	R14
    007AA 1CFF      ROL	R15
    007AB 16E2      CP	R14,R18
    007AC 06F3      CPC	R15,R19
    007AD F018      BCS	0x07B1
    007AE 1AE2      SUB	R14,R18
    007AF 0AF3      SBC	R15,R19
    007B0 9503      INC	R16
    007B1 958A      DEC	R24
    007B2 F7A1      BNE	0x07A7
    007B3 F416      BRTC	0x07B6
    007B4 2D0E      MOV	R16,R14
    007B5 2D1F      MOV	R17,R15
    007B6 9189      LD	R24,Y+
    007B7 90F9      LD	R15,Y+
    007B8 90E9      LD	R14,Y+
    007B9 9508      RET
pop_xgset30FC:
    007BA 90A9      LD	R10,Y+
    007BB 90B9      LD	R11,Y+
    007BC 90C9      LD	R12,Y+
    007BD 90D9      LD	R13,Y+
    007BE 90E9      LD	R14,Y+
    007BF 90F9      LD	R15,Y+
    007C0 9149      LD	R20,Y+
    007C1 9159      LD	R21,Y+
    007C2 9508      RET
pop_xgsetF0FC:
    007C3 90A9      LD	R10,Y+
    007C4 90B9      LD	R11,Y+
    007C5 90C9      LD	R12,Y+
    007C6 90D9      LD	R13,Y+
    007C7 90E9      LD	R14,Y+
    007C8 90F9      LD	R15,Y+
    007C9 9149      LD	R20,Y+
    007CA 9159      LD	R21,Y+
    007CB 9169      LD	R22,Y+
    007CC 9179      LD	R23,Y+
    007CD 9508      RET
push_xgsetF0FC:
    007CE 937A      ST	-Y,R23
    007CF 936A      ST	-Y,R22
push_xgset30FC:
    007D0 935A      ST	-Y,R21
    007D1 934A      ST	-Y,R20
push_xgset00FC:
    007D2 92FA      ST	-Y,R15
    007D3 92EA      ST	-Y,R14
push_xgset003C:
    007D4 92DA      ST	-Y,R13
    007D5 92CA      ST	-Y,R12
    007D6 92BA      ST	-Y,R11
    007D7 92AA      ST	-Y,R10
    007D8 9508      RET
push_xgset300C:
    007D9 935A      ST	-Y,R21
    007DA 934A      ST	-Y,R20
    007DB 92BA      ST	-Y,R11
    007DC 92AA      ST	-Y,R10
    007DD 9508      RET
pop_xgset300C:
    007DE 90A9      LD	R10,Y+
    007DF 90B9      LD	R11,Y+
    007E0 9149      LD	R20,Y+
    007E1 9159      LD	R21,Y+
    007E2 9508      RET
push_xgsetF00C:
    007E3 937A      ST	-Y,R23
    007E4 936A      ST	-Y,R22
    007E5 935A      ST	-Y,R21
    007E6 934A      ST	-Y,R20
    007E7 92BA      ST	-Y,R11
    007E8 92AA      ST	-Y,R10
    007E9 9508      RET
pop_xgsetF00C:
    007EA 90A9      LD	R10,Y+
    007EB 90B9      LD	R11,Y+
    007EC 9149      LD	R20,Y+
    007ED 9159      LD	R21,Y+
    007EE 9169      LD	R22,Y+
    007EF 9179      LD	R23,Y+
    007F0 9508      RET
push_xgset303C:
    007F1 935A      ST	-Y,R21
    007F2 934A      ST	-Y,R20
    007F3 92DA      ST	-Y,R13
    007F4 92CA      ST	-Y,R12
    007F5 92BA      ST	-Y,R11
    007F6 92AA      ST	-Y,R10
    007F7 9508      RET
pop_xgset303C:
    007F8 90A9      LD	R10,Y+
    007F9 90B9      LD	R11,Y+
    007FA 90C9      LD	R12,Y+
    007FB 90D9      LD	R13,Y+
    007FC 9149      LD	R20,Y+
    007FD 9159      LD	R21,Y+
    007FE 9508      RET
push_xgsetF03C:
    007FF 937A      ST	-Y,R23
    00800 936A      ST	-Y,R22
    00801 935A      ST	-Y,R21
    00802 934A      ST	-Y,R20
    00803 92DA      ST	-Y,R13
    00804 92CA      ST	-Y,R12
    00805 92BA      ST	-Y,R11
    00806 92AA      ST	-Y,R10
    00807 9508      RET
pop_xgsetF03C:
    00808 90A9      LD	R10,Y+
    00809 90B9      LD	R11,Y+
    0080A 90C9      LD	R12,Y+
    0080B 90D9      LD	R13,Y+
    0080C 9149      LD	R20,Y+
    0080D 9159      LD	R21,Y+
    0080E 9169      LD	R22,Y+
    0080F 9179      LD	R23,Y+
    00810 9508      RET
asgncblk:
    00811 93AA      ST	-Y,R26
    00812 93BA      ST	-Y,R27
    00813 93EA      ST	-Y,R30
    00814 93FA      ST	-Y,R31
    00815 920A      ST	-Y,R0
    00816 81AF      LDD	R26,Y+7
    00817 85B8      LDD	R27,Y+8
    00818 81ED      LDD	R30,Y+5
    00819 81FE      LDD	R31,Y+6
    0081A 3000      CPI	R16,0
    0081B 0701      CPC	R16,R17
    0081C F031      BEQ	0x0823
    0081D 95C8      LPM
    0081E 920D      ST	X+,R0
    0081F 9631      ADIW	R30,1
    00820 5001      SUBI	R16,1
    00821 4010      SBCI	R17,0
    00822 CFF7      RJMP	0x081A
    00823 9009      LD	R0,Y+
    00824 91F9      LD	R31,Y+
    00825 91E9      LD	R30,Y+
    00826 91B9      LD	R27,Y+
    00827 91A9      LD	R26,Y+
    00828 9624      ADIW	R28,4
    00829 9508      RET
