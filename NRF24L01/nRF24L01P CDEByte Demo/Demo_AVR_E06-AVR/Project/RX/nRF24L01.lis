                        .module nRF24L01.c
                        .area text(rom, con, rel)
 0000                   .dbfile ..\..\..\..\..\..\..\ODMPRO~1\E06-RFTB\E06-AVR\DEMO_AVR\nRF24L01P\Source\nRF24L01.c
                        .area data(ram, con, rel)
 0000                   .dbfile ..\..\..\..\..\..\..\ODMPRO~1\E06-RFTB\E06-AVR\DEMO_AVR\nRF24L01P\Source\nRF24L01.c
 0000           _CE_Status::
 0000                   .blkb 1
                        .area idata
 0000 00                .byte 0
                        .area data(ram, con, rel)
 0001                   .dbfile ..\..\..\..\..\..\..\ODMPRO~1\E06-RFTB\E06-AVR\DEMO_AVR\nRF24L01P\Source\nRF24L01.c
 0001                   .dbfile F:\产品\ODMPRO~1\E06-RFTB\E06-AVR\DEMO_AVR\nRF24L01P\Source\nRF24L01.c
 0001                   .dbsym e CE_Status _CE_Status c
                        .area text(rom, con, rel)
 0000                   .dbfile F:\产品\ODMPRO~1\E06-RFTB\E06-AVR\DEMO_AVR\nRF24L01P\Source\nRF24L01.c
 0000                   .dbfunc e L01_GetCEStatus _L01_GetCEStatus fc
                        .even
 0000           _L01_GetCEStatus::
 0000                   .dbline -1
 0000                   .dbline 29
 0000           ; /*
 0000           ; ================================================================================
 0000           ; Copyright(c)  Yihe Embedded Studio, All rights reserved.
 0000           ;               www.yhmcu.com
 0000           ;               http://yhmcu.taobao.com
 0000           ; 
 0000           ; File Name   : nRF24L01.c
 0000           ; Description : nRF24L01 low level operations and configurations.
 0000           ; Author      : ShawZhang,LiYong
 0000           ; Date        : 2012-4-17 9:08:36
 0000           ; Version     : 2.0
 0000           ; Compiler    : Any
 0000           ; Note        : None
 0000           ; ================================================================================
 0000           ; */
 0000           ; #define _nRF24L01_C_
 0000           ; #include "nRF24L01.h"
 0000           ; 
 0000           ; INT8U CE_Status = 0;
 0000           ; /*
 0000           ; ================================================================================
 0000           ; Function : L01_GetCEStatus( )
 0000           ; Description : Get the status of the CE PIN
 0000           ; Input : NONE
 0000           ; Output: 1:CE=1, 0:CE=0
 0000           ; ================================================================================
 0000           ; */
 0000           ; INT8U L01_GetCEStatus( void )
 0000           ; {
 0000                   .dbline 30
 0000           ;       return CE_Status;
 0000 00910000          lds R16,_CE_Status
 0004                   .dbline -2
 0004           L5:
 0004                   .dbline 0 ; func end
 0004 0895              ret
 0006                   .dbend
 0006                   .dbfunc e L01_SetCE _L01_SetCE fV
 0006           ;         status -> R16
                        .even
 0006           _L01_SetCE::
 0006                   .dbline -1
 0006                   .dbline 41
 0006           ; }
 0006           ; /*
 0006           ; ================================================================================
 0006           ; Function : L01_SetCE( )
 0006           ; Description : Set the CE PIN as 1 or 0
 0006           ; Input : -status, 1: CE=1, 0: CE=0
 0006           ; Output: None
 0006           ; ================================================================================
 0006           ; */
 0006           ; void L01_SetCE( INT8U status )
 0006           ; {
 0006                   .dbline 42
 0006           ;       CE_Status = status;
 0006 00930000          sts _CE_Status,R16
 000A                   .dbline 43
 000A           ;       if( status == 0 )  { L01_CE_LOW( ); }
 000A 0023              tst R16
 000C 19F4              brne L7
 000E           X0:
 000E                   .dbline 43
 000E                   .dbline 43
 000E                   .dbline 43
 000E C798              cbi 0x18,7
 0010                   .dbline 43
 0010 BF9A              sbi 0x17,7
 0012                   .dbline 43
 0012                   .dbline 43
 0012                   .dbline 43
 0012 02C0              rjmp L8
 0014           L7:
 0014                   .dbline 44
 0014           ;       else               { L01_CE_HIGH( ); }
 0014                   .dbline 44
 0014                   .dbline 44
 0014 C79A              sbi 0x18,7
 0016                   .dbline 44
 0016 BF9A              sbi 0x17,7
 0018                   .dbline 44
 0018                   .dbline 44
 0018                   .dbline 44
 0018           L8:
 0018                   .dbline -2
 0018           L6:
 0018                   .dbline 0 ; func end
 0018 0895              ret
 001A                   .dbsym r status 16 c
 001A                   .dbend
 001A                   .dbfunc e L01_ReadSingleReg _L01_ReadSingleReg fc
 001A           ;           btmp -> R10
 001A           ;           Addr -> R10
                        .even
 001A           _L01_ReadSingleReg::
 001A AA92              st -y,R10
 001C A02E              mov R10,R16
 001E                   .dbline -1
 001E                   .dbline 55
 001E           ; }
 001E           ; /*
 001E           ; ================================================================================
 001E           ; Function : L01_ReadSingleReg( )
 001E           ; Description : Read a single register of nRF24L01
 001E           ; Input : -Addr, The address of the register
 001E           ; Output: The value read from the register
 001E           ; ================================================================================
 001E           ; */
 001E           ; INT8U L01_ReadSingleReg( INT8U Addr )
 001E           ; {
 001E                   .dbline 57
 001E           ;     INT8U btmp;
 001E           ;     L01_CSN_LOW( );
 001E                   .dbline 57
 001E C298              cbi 0x18,2
 0020                   .dbline 57
 0020 BA9A              sbi 0x17,2
 0022                   .dbline 57
 0022                   .dbline 57
 0022                   .dbline 58
 0022           ;     SPI_ExchangeByte( R_REGISTER | Addr );
 0022 0A2D              mov R16,R10
 0024 00D0              rcall _SPI_ExchangeByte
 0026                   .dbline 59
 0026           ;     btmp = SPI_ExchangeByte( 0xFF );
 0026 0FEF              ldi R16,255
 0028 00D0              rcall _SPI_ExchangeByte
 002A A02E              mov R10,R16
 002C                   .dbline 60
 002C           ;     L01_CSN_HIGH( );
 002C                   .dbline 60
 002C C29A              sbi 0x18,2
 002E                   .dbline 60
 002E BA9A              sbi 0x17,2
 0030                   .dbline 60
 0030                   .dbline 60
 0030                   .dbline 61
 0030           ;     return btmp;
 0030                   .dbline -2
 0030           L9:
 0030                   .dbline 0 ; func end
 0030 A990              ld R10,y+
 0032 0895              ret
 0034                   .dbsym r btmp 10 c
 0034                   .dbsym r Addr 10 c
 0034                   .dbend
 0034                   .dbfunc e L01_WriteSingleReg _L01_WriteSingleReg fV
 0034           ;            tmp -> R10
 0034           ;          Value -> R12
 0034           ;           Addr -> R20
                        .even
 0034           _L01_WriteSingleReg::
 0034 00D0              rcall push_xgset303C
 0036 C22E              mov R12,R18
 0038 402F              mov R20,R16
 003A                   .dbline -1
 003A                   .dbline 94
 003A           ; }
 003A           ; /*
 003A           ; ================================================================================
 003A           ; Function : L01_ReadMultiReg( )
 003A           ; Description : Read several registers of nRF24L01
 003A           ; Input : -StartAddr, The start address of the registers
 003A           ;         -nBytes, How many registers do you want to read
 003A           ;         -pBuff, The buffer to save the values
 003A           ; Output: None
 003A           ; ================================================================================
 003A           ; */
 003A           ; /*void L01_ReadMultiReg( INT8U StartAddr, INT8U nBytes, INT8U *pBuff )
 003A           ; {
 003A           ;     INT8U btmp;
 003A           ;     L01_CSN_LOW( );
 003A           ;     SPI_ExchangeByte( R_REGISTER | StartAddr );
 003A           ;     for( btmp = 0; btmp < nBytes; btmp ++ )
 003A           ;     {
 003A           ;         *( pBuff + btmp ) = SPI_ExchangeByte( 0xFF );
 003A           ;     }
 003A           ;     L01_CSN_HIGH( );
 003A           ; }
 003A           ; 
 003A           ; ================================================================================
 003A           ; Function : L01_WriteSingleReg( )
 003A           ; Description : Write a single byte to a register
 003A           ; Input : -Addr, The address of the register
 003A           ;         -Value, The value to be written
 003A           ; Output: None
 003A           ; ================================================================================
 003A           ; */
 003A           ; void L01_WriteSingleReg( INT8U Addr, INT8U Value )
 003A           ; {
 003A                   .dbline 95
 003A           ;       INT8U tmp = L01_GetCEStatus( );
 003A E2DF              rcall _L01_GetCEStatus
 003C A02E              mov R10,R16
 003E                   .dbline 96
 003E           ;       L01_SetCE( 0 );
 003E 0027              clr R16
 0040 E2DF              rcall _L01_SetCE
 0042                   .dbline 97
 0042           ;     L01_CSN_LOW( );
 0042                   .dbline 97
 0042 C298              cbi 0x18,2
 0044                   .dbline 97
 0044 BA9A              sbi 0x17,2
 0046                   .dbline 97
 0046                   .dbline 97
 0046                   .dbline 98
 0046           ;     SPI_ExchangeByte( W_REGISTER | Addr );
 0046 042F              mov R16,R20
 0048 0062              ori R16,32
 004A 00D0              rcall _SPI_ExchangeByte
 004C                   .dbline 99
 004C           ;     SPI_ExchangeByte( Value );
 004C 0C2D              mov R16,R12
 004E 00D0              rcall _SPI_ExchangeByte
 0050                   .dbline 100
 0050           ;     L01_CSN_HIGH( );
 0050                   .dbline 100
 0050 C29A              sbi 0x18,2
 0052                   .dbline 100
 0052 BA9A              sbi 0x17,2
 0054                   .dbline 100
 0054                   .dbline 100
 0054                   .dbline 101
 0054           ;       L01_SetCE( tmp );
 0054 0A2D              mov R16,R10
 0056 D7DF              rcall _L01_SetCE
 0058                   .dbline -2
 0058           L10:
 0058                   .dbline 0 ; func end
 0058 00C0              rjmp pop_xgset303C
 005A                   .dbsym r tmp 10 c
 005A                   .dbsym r Value 12 c
 005A                   .dbsym r Addr 20 c
 005A                   .dbend
 005A                   .dbfunc e L01_WriteMultiReg _L01_WriteMultiReg fV
 005A           ;            tmp -> R10
 005A           ;              i -> R12
 005A           ;         Length -> R14
 005A           ;          pBuff -> R20,R21
 005A           ;      StartAddr -> R22
                        .even
 005A           _L01_WriteMultiReg::
 005A 00D0              rcall push_xgsetF0FC
 005C A901              movw R20,R18
 005E 602F              mov R22,R16
 0060 EA84              ldd R14,y+10
 0062                   .dbline -1
 0062                   .dbline 114
 0062           ; }
 0062           ; /*
 0062           ; ================================================================================
 0062           ; Function : L01_WriteMultiReg( )
 0062           ; Description : Read several registers of nRF24L01
 0062           ; Input : -StartAddr, The start address of the registers
 0062           ;         -pBuff, The buffer store the values
 0062           ;         -Length, How many registers do you want to write
 0062           ; Output: None
 0062           ; ================================================================================
 0062           ; */
 0062           ; void L01_WriteMultiReg( INT8U StartAddr, INT8U *pBuff, INT8U Length )
 0062           ; {
 0062                   .dbline 116
 0062           ;     INT8U i;
 0062           ;       INT8U tmp = L01_GetCEStatus( );
 0062 CEDF              rcall _L01_GetCEStatus
 0064 A02E              mov R10,R16
 0066                   .dbline 117
 0066           ;       L01_SetCE( 0 );
 0066 0027              clr R16
 0068 CEDF              rcall _L01_SetCE
 006A                   .dbline 118
 006A           ;     L01_CSN_LOW( );
 006A                   .dbline 118
 006A C298              cbi 0x18,2
 006C                   .dbline 118
 006C BA9A              sbi 0x17,2
 006E                   .dbline 118
 006E                   .dbline 118
 006E                   .dbline 119
 006E           ;     SPI_ExchangeByte( W_REGISTER | StartAddr );
 006E 062F              mov R16,R22
 0070 0062              ori R16,32
 0072 00D0              rcall _SPI_ExchangeByte
 0074                   .dbline 120
 0074           ;     for( i = 0; i < Length; i ++ )
 0074 CC24              clr R12
 0076 07C0              rjmp L15
 0078           L12:
 0078                   .dbline 121
 0078           ;     {
 0078                   .dbline 122
 0078           ;         SPI_ExchangeByte( *( pBuff + i ) );
 0078 EC2D              mov R30,R12
 007A FF27              clr R31
 007C E40F              add R30,R20
 007E F51F              adc R31,R21
 0080 0081              ldd R16,z+0
 0082 00D0              rcall _SPI_ExchangeByte
 0084                   .dbline 123
 0084           ;     }
 0084           L13:
 0084                   .dbline 120
 0084 C394              inc R12
 0086           L15:
 0086                   .dbline 120
 0086 CE14              cp R12,R14
 0088 B8F3              brlo L12
 008A           X1:
 008A                   .dbline 124
 008A           ;     L01_CSN_HIGH( );
 008A                   .dbline 124
 008A C29A              sbi 0x18,2
 008C                   .dbline 124
 008C BA9A              sbi 0x17,2
 008E                   .dbline 124
 008E                   .dbline 124
 008E                   .dbline 125
 008E           ;       L01_SetCE( tmp );
 008E 0A2D              mov R16,R10
 0090 BADF              rcall _L01_SetCE
 0092                   .dbline -2
 0092           L11:
 0092                   .dbline 0 ; func end
 0092 00C0              rjmp pop_xgsetF0FC
 0094                   .dbsym r tmp 10 c
 0094                   .dbsym r i 12 c
 0094                   .dbsym r Length 14 c
 0094                   .dbsym r pBuff 20 pc
 0094                   .dbsym r StartAddr 22 c
 0094                   .dbend
 0094                   .dbfunc e L01_FlushTX _L01_FlushTX fV
                        .even
 0094           _L01_FlushTX::
 0094                   .dbline -1
 0094                   .dbline 136
 0094           ; }
 0094           ; /*
 0094           ; ================================================================================
 0094           ; Function : L01_FlushTX( )
 0094           ; Description : Flush the TX buffer
 0094           ; Input : None
 0094           ; Output: None
 0094           ; ================================================================================
 0094           ; */
 0094           ; void L01_FlushTX( void )
 0094           ; {
 0094                   .dbline 137
 0094           ;     L01_CSN_LOW( );
 0094                   .dbline 137
 0094 C298              cbi 0x18,2
 0096                   .dbline 137
 0096 BA9A              sbi 0x17,2
 0098                   .dbline 137
 0098                   .dbline 137
 0098                   .dbline 138
 0098           ;     SPI_ExchangeByte( FLUSH_TX );
 0098 01EE              ldi R16,225
 009A 00D0              rcall _SPI_ExchangeByte
 009C                   .dbline 139
 009C           ;     L01_CSN_HIGH( );
 009C                   .dbline 139
 009C C29A              sbi 0x18,2
 009E                   .dbline 139
 009E BA9A              sbi 0x17,2
 00A0                   .dbline 139
 00A0                   .dbline 139
 00A0                   .dbline -2
 00A0           L16:
 00A0                   .dbline 0 ; func end
 00A0 0895              ret
 00A2                   .dbend
 00A2                   .dbfunc e L01_FlushRX _L01_FlushRX fV
                        .even
 00A2           _L01_FlushRX::
 00A2                   .dbline -1
 00A2                   .dbline 150
 00A2           ; }
 00A2           ; /*
 00A2           ; ================================================================================
 00A2           ; Function : L01_FlushRX( )
 00A2           ; Description : Flush the RX buffer
 00A2           ; Input : None
 00A2           ; Output: None
 00A2           ; ================================================================================
 00A2           ; */
 00A2           ; void L01_FlushRX( void )
 00A2           ; {
 00A2                   .dbline 151
 00A2           ;     L01_CSN_LOW( );
 00A2                   .dbline 151
 00A2 C298              cbi 0x18,2
 00A4                   .dbline 151
 00A4 BA9A              sbi 0x17,2
 00A6                   .dbline 151
 00A6                   .dbline 151
 00A6                   .dbline 152
 00A6           ;     SPI_ExchangeByte( FLUSH_RX );
 00A6 02EE              ldi R16,226
 00A8 00D0              rcall _SPI_ExchangeByte
 00AA                   .dbline 153
 00AA           ;     L01_CSN_HIGH( );
 00AA                   .dbline 153
 00AA C29A              sbi 0x18,2
 00AC                   .dbline 153
 00AC BA9A              sbi 0x17,2
 00AE                   .dbline 153
 00AE                   .dbline 153
 00AE                   .dbline -2
 00AE           L17:
 00AE                   .dbline 0 ; func end
 00AE 0895              ret
 00B0                   .dbend
 00B0                   .dbfunc e L01_ReuseTXPayload _L01_ReuseTXPayload fV
                        .even
 00B0           _L01_ReuseTXPayload::
 00B0                   .dbline -1
 00B0                   .dbline 164
 00B0           ; }
 00B0           ; /*
 00B0           ; ================================================================================
 00B0           ; Function : L01_ReuseTXPayload( )
 00B0           ; Description : Reuse the last transmitted payload
 00B0           ; Input : None
 00B0           ; Output: None
 00B0           ; ================================================================================
 00B0           ; */
 00B0           ; void L01_ReuseTXPayload( void )
 00B0           ; {
 00B0                   .dbline 165
 00B0           ;     L01_CSN_LOW( );
 00B0                   .dbline 165
 00B0 C298              cbi 0x18,2
 00B2                   .dbline 165
 00B2 BA9A              sbi 0x17,2
 00B4                   .dbline 165
 00B4                   .dbline 165
 00B4                   .dbline 166
 00B4           ;     SPI_ExchangeByte( REUSE_TX_PL );
 00B4 03EE              ldi R16,227
 00B6 00D0              rcall _SPI_ExchangeByte
 00B8                   .dbline 167
 00B8           ;     L01_CSN_HIGH( );
 00B8                   .dbline 167
 00B8 C29A              sbi 0x18,2
 00BA                   .dbline 167
 00BA BA9A              sbi 0x17,2
 00BC                   .dbline 167
 00BC                   .dbline 167
 00BC                   .dbline -2
 00BC           L18:
 00BC                   .dbline 0 ; func end
 00BC 0895              ret
 00BE                   .dbend
 00BE                   .dbfunc e L01_Nop _L01_Nop fV
                        .even
 00BE           _L01_Nop::
 00BE                   .dbline -1
 00BE                   .dbline 178
 00BE           ; }
 00BE           ; /*
 00BE           ; ================================================================================
 00BE           ; Function : L01_Nop( )
 00BE           ; Description : nop operation of nRF24L01
 00BE           ; Input : None
 00BE           ; Output: None
 00BE           ; ================================================================================
 00BE           ; */
 00BE           ; void L01_Nop( void )
 00BE           ; {
 00BE                   .dbline 179
 00BE           ;     L01_CSN_LOW( );
 00BE                   .dbline 179
 00BE C298              cbi 0x18,2
 00C0                   .dbline 179
 00C0 BA9A              sbi 0x17,2
 00C2                   .dbline 179
 00C2                   .dbline 179
 00C2                   .dbline 180
 00C2           ;     SPI_ExchangeByte( L01_NOP );
 00C2 0FEF              ldi R16,255
 00C4 00D0              rcall _SPI_ExchangeByte
 00C6                   .dbline 181
 00C6           ;     L01_CSN_HIGH( );
 00C6                   .dbline 181
 00C6 C29A              sbi 0x18,2
 00C8                   .dbline 181
 00C8 BA9A              sbi 0x17,2
 00CA                   .dbline 181
 00CA                   .dbline 181
 00CA                   .dbline -2
 00CA           L19:
 00CA                   .dbline 0 ; func end
 00CA 0895              ret
 00CC                   .dbend
 00CC                   .dbfunc e L01_ReadStatusReg _L01_ReadStatusReg fc
 00CC           ;         Status -> R10
                        .even
 00CC           _L01_ReadStatusReg::
 00CC AA92              st -y,R10
 00CE                   .dbline -1
 00CE                   .dbline 192
 00CE           ; }
 00CE           ; /*
 00CE           ; ================================================================================
 00CE           ; Function : L01_ReadStatusReg( )
 00CE           ; Description : Read statu register of nRF24L01
 00CE           ; Input : None
 00CE           ; Output: Statu register of nRF24L01
 00CE           ; ================================================================================
 00CE           ; */
 00CE           ; INT8U L01_ReadStatusReg( void )
 00CE           ; {
 00CE                   .dbline 194
 00CE           ;     INT8U Status;
 00CE           ;     L01_CSN_LOW( );
 00CE                   .dbline 194
 00CE C298              cbi 0x18,2
 00D0                   .dbline 194
 00D0 BA9A              sbi 0x17,2
 00D2                   .dbline 194
 00D2                   .dbline 194
 00D2                   .dbline 195
 00D2           ;     Status = SPI_ExchangeByte( R_REGISTER + L01REG_STATUS );
 00D2 07E0              ldi R16,7
 00D4 00D0              rcall _SPI_ExchangeByte
 00D6 A02E              mov R10,R16
 00D8                   .dbline 196
 00D8           ;     L01_CSN_HIGH( );
 00D8                   .dbline 196
 00D8 C29A              sbi 0x18,2
 00DA                   .dbline 196
 00DA BA9A              sbi 0x17,2
 00DC                   .dbline 196
 00DC                   .dbline 196
 00DC                   .dbline 197
 00DC           ;     return Status;
 00DC                   .dbline -2
 00DC           L20:
 00DC                   .dbline 0 ; func end
 00DC A990              ld R10,y+
 00DE 0895              ret
 00E0                   .dbsym r Status 10 c
 00E0                   .dbend
 00E0                   .dbfunc e L01_ClearIRQ _L01_ClearIRQ fV
 00E0           ;           btmp -> R10
 00E0           ;     IRQ_Source -> R20
                        .even
 00E0           _L01_ClearIRQ::
 00E0 AA92              st -y,R10
 00E2 4A93              st -y,R20
 00E4 402F              mov R20,R16
 00E6                   .dbline -1
 00E6                   .dbline 208
 00E6           ; }
 00E6           ; /*
 00E6           ; ================================================================================
 00E6           ; Function : L01_ClearIRQ( )
 00E6           ; Description : Clear IRQ cuased by nRF24L01
 00E6           ; Input : None
 00E6           ; Output: None
 00E6           ; ================================================================================
 00E6           ; */
 00E6           ; void L01_ClearIRQ( INT8U IRQ_Source )
 00E6           ; {
 00E6                   .dbline 209
 00E6           ;     INT8U btmp = 0;
 00E6                   .dbline 211
 00E6           ; 
 00E6           ;     IRQ_Source &= ( 1<<RX_DR ) | ( 1<<TX_DS ) | ( 1<<MAX_RT );
 00E6 4077              andi R20,112
 00E8                   .dbline 212
 00E8           ;     btmp = L01_ReadStatusReg( );
 00E8 F1DF              rcall _L01_ReadStatusReg
 00EA A02E              mov R10,R16
 00EC                   .dbline 213
 00EC           ;     L01_CSN_LOW( );
 00EC                   .dbline 213
 00EC C298              cbi 0x18,2
 00EE                   .dbline 213
 00EE BA9A              sbi 0x17,2
 00F0                   .dbline 213
 00F0                   .dbline 213
 00F0                   .dbline 214
 00F0           ;       L01_WriteSingleReg( L01REG_STATUS, IRQ_Source | btmp );
 00F0 242F              mov R18,R20
 00F2 202B              or R18,R16
 00F4 07E0              ldi R16,7
 00F6 9EDF              rcall _L01_WriteSingleReg
 00F8                   .dbline 215
 00F8           ;     L01_CSN_HIGH( );
 00F8                   .dbline 215
 00F8 C29A              sbi 0x18,2
 00FA                   .dbline 215
 00FA BA9A              sbi 0x17,2
 00FC                   .dbline 215
 00FC                   .dbline 215
 00FC                   .dbline 216
 00FC           ;     L01_ReadStatusReg( );
 00FC E7DF              rcall _L01_ReadStatusReg
 00FE                   .dbline -2
 00FE           L21:
 00FE                   .dbline 0 ; func end
 00FE 4991              ld R20,y+
 0100 A990              ld R10,y+
 0102 0895              ret
 0104                   .dbsym r btmp 10 c
 0104                   .dbsym r IRQ_Source 20 c
 0104                   .dbend
 0104                   .dbfunc e L01_ReadIRQSource _L01_ReadIRQSource fc
                        .even
 0104           _L01_ReadIRQSource::
 0104                   .dbline -1
 0104                   .dbline 227
 0104           ; }
 0104           ; /*
 0104           ; ================================================================================
 0104           ; Function : L01_ReadIRQSource( )
 0104           ; Description : Read the IRQ source of nRF24L01+
 0104           ; Input : None
 0104           ; Output: IRQ source mask code
 0104           ; ================================================================================
 0104           ; */
 0104           ; INT8U L01_ReadIRQSource( void )
 0104           ; {
 0104                   .dbline 228
 0104           ;     return ( L01_ReadStatusReg( ) & ( ( 1<<RX_DR ) | ( 1<<TX_DS ) | ( 1<<MAX_RT ) ) );
 0104 E3DF              rcall _L01_ReadStatusReg
 0106 0077              andi R16,112
 0108                   .dbline -2
 0108           L22:
 0108                   .dbline 0 ; func end
 0108 0895              ret
 010A                   .dbend
 010A                   .dbfunc e L01_ReadTopFIFOWidth _L01_ReadTopFIFOWidth fc
 010A           ;           btmp -> R10
                        .even
 010A           _L01_ReadTopFIFOWidth::
 010A AA92              st -y,R10
 010C                   .dbline -1
 010C                   .dbline 239
 010C           ; }
 010C           ; /*
 010C           ; ================================================================================
 010C           ; Function : L01_ReadTopFIFOWidth( )
 010C           ; Description : Read the payload width of the top buffer of FIFO
 010C           ; Input : None
 010C           ; Output: The width of the pipe buffer
 010C           ; ================================================================================
 010C           ; */
 010C           ; INT8U L01_ReadTopFIFOWidth( void )
 010C           ; {
 010C                   .dbline 241
 010C           ;     INT8U btmp;
 010C           ;     L01_CSN_LOW( );
 010C                   .dbline 241
 010C C298              cbi 0x18,2
 010E                   .dbline 241
 010E BA9A              sbi 0x17,2
 0110                   .dbline 241
 0110                   .dbline 241
 0110                   .dbline 242
 0110           ;     SPI_ExchangeByte( R_RX_PL_WID );
 0110 00E6              ldi R16,96
 0112 00D0              rcall _SPI_ExchangeByte
 0114                   .dbline 243
 0114           ;     btmp = SPI_ExchangeByte( 0xFF );
 0114 0FEF              ldi R16,255
 0116 00D0              rcall _SPI_ExchangeByte
 0118 A02E              mov R10,R16
 011A                   .dbline 244
 011A           ;     L01_CSN_HIGH( );
 011A                   .dbline 244
 011A C29A              sbi 0x18,2
 011C                   .dbline 244
 011C BA9A              sbi 0x17,2
 011E                   .dbline 244
 011E                   .dbline 244
 011E                   .dbline 245
 011E           ;     return btmp;
 011E                   .dbline -2
 011E           L23:
 011E                   .dbline 0 ; func end
 011E A990              ld R10,y+
 0120 0895              ret
 0122                   .dbsym r btmp 10 c
 0122                   .dbend
 0122                   .dbfunc e L01_ReadRXPayload _L01_ReadRXPayload fc
 0122           ;          width -> R10
 0122           ;        PipeNum -> R20
 0122           ;          pBuff -> R12,R13
                        .even
 0122           _L01_ReadRXPayload::
 0122 00D0              rcall push_xgset30FC
 0124 6801              movw R12,R16
 0126                   .dbline -1
 0126                   .dbline 256
 0126           ; }
 0126           ; /*
 0126           ; ================================================================================
 0126           ; Function : L01_ReadRXPayload( )
 0126           ; Description : Read the RX payload from internal buffer
 0126           ; Input : -pBuff, buffer to store the data
 0126           ; Output: The length of data read
 0126           ; ================================================================================
 0126           ; */
 0126           ; INT8U L01_ReadRXPayload( INT8U *pBuff )
 0126           ; {
 0126                   .dbline 258
 0126           ;     INT8U width, PipeNum;
 0126           ;     PipeNum = ( L01_ReadSingleReg( L01REG_STATUS ) >> 1 ) & 0x07;
 0126 07E0              ldi R16,7
 0128 78DF              rcall _L01_ReadSingleReg
 012A 402F              mov R20,R16
 012C 4695              lsr R20
 012E 4770              andi R20,7
 0130                   .dbline 259
 0130           ;     width = L01_ReadTopFIFOWidth( );
 0130 ECDF              rcall _L01_ReadTopFIFOWidth
 0132 A02E              mov R10,R16
 0134                   .dbline 261
 0134           ; 
 0134           ;     L01_CSN_LOW( );
 0134                   .dbline 261
 0134 C298              cbi 0x18,2
 0136                   .dbline 261
 0136 BA9A              sbi 0x17,2
 0138                   .dbline 261
 0138                   .dbline 261
 0138                   .dbline 262
 0138           ;     SPI_ExchangeByte( R_RX_PAYLOAD );
 0138 01E6              ldi R16,97
 013A 00D0              rcall _SPI_ExchangeByte
 013C                   .dbline 263
 013C           ;     for( PipeNum = 0; PipeNum < width; PipeNum ++ )
 013C 4427              clr R20
 013E 09C0              rjmp L28
 0140           L25:
 0140                   .dbline 264
 0140           ;     {
 0140                   .dbline 265
 0140           ;         *( pBuff + PipeNum ) = SPI_ExchangeByte( 0xFF );
 0140 0FEF              ldi R16,255
 0142 00D0              rcall _SPI_ExchangeByte
 0144 E02E              mov R14,R16
 0146 E42F              mov R30,R20
 0148 FF27              clr R31
 014A EC0D              add R30,R12
 014C FD1D              adc R31,R13
 014E E082              std z+0,R14
 0150                   .dbline 266
 0150           ;     }
 0150           L26:
 0150                   .dbline 263
 0150 4395              inc R20
 0152           L28:
 0152                   .dbline 263
 0152 4A15              cp R20,R10
 0154 A8F3              brlo L25
 0156           X2:
 0156                   .dbline 267
 0156           ;     L01_CSN_HIGH( );
 0156                   .dbline 267
 0156 C29A              sbi 0x18,2
 0158                   .dbline 267
 0158 BA9A              sbi 0x17,2
 015A                   .dbline 267
 015A                   .dbline 267
 015A                   .dbline 268
 015A           ;     L01_FlushRX( );
 015A A3DF              rcall _L01_FlushRX
 015C                   .dbline 269
 015C           ;     return width;
 015C 0A2D              mov R16,R10
 015E                   .dbline -2
 015E           L24:
 015E                   .dbline 0 ; func end
 015E 00C0              rjmp pop_xgset30FC
 0160                   .dbsym r width 10 c
 0160                   .dbsym r PipeNum 20 c
 0160                   .dbsym r pBuff 12 pc
 0160                   .dbend
 0160                   .dbfunc e L01_WriteTXPayload_Ack _L01_WriteTXPayload_Ack fV
 0160           ;         length -> R12
 0160           ;           btmp -> R10
 0160           ;         nBytes -> R10
 0160           ;          pBuff -> R14,R15
                        .even
 0160           _L01_WriteTXPayload_Ack::
 0160 00D0              rcall push_xgset30FC
 0162 A22E              mov R10,R18
 0164 7801              movw R14,R16
 0166                   .dbline -1
 0166                   .dbline 282
 0166           ; }
 0166           ; /*
 0166           ; ================================================================================
 0166           ; Function : L01_WriteTXPayload( )
 0166           ; Description : Write TX payload to a pipe and prx will return ack back
 0166           ; Input : -PipeNum, number of the pipe
 0166           ;         -pBuff, A buffer stores the data
 0166           ;         -nBytes, How many bytes to be wrote to
 0166           ; Output: None
 0166           ; ================================================================================
 0166           ; */
 0166           ; void L01_WriteTXPayload_Ack( INT8U *pBuff, INT8U nBytes )
 0166           ; {
 0166                   .dbline 284
 0166           ;     INT8U btmp;
 0166           ;     INT8U length = ( nBytes > 32 ) ? 32 : nBytes;
 0166 80E2              ldi R24,32
 0168 8A15              cp R24,R10
 016A 18F4              brsh L30
 016C           X3:
 016C 40E2              ldi R20,32
 016E 50E0              ldi R21,0
 0170 02C0              rjmp L31
 0172           L30:
 0172 4A2D              mov R20,R10
 0174 5527              clr R21
 0176           L31:
 0176 C42E              mov R12,R20
 0178                   .dbline 286
 0178           ; 
 0178           ;     L01_FlushTX( );
 0178 8DDF              rcall _L01_FlushTX
 017A                   .dbline 287
 017A           ;     L01_CSN_LOW( );
 017A                   .dbline 287
 017A C298              cbi 0x18,2
 017C                   .dbline 287
 017C BA9A              sbi 0x17,2
 017E                   .dbline 287
 017E                   .dbline 287
 017E                   .dbline 288
 017E           ;     SPI_ExchangeByte( W_TX_PAYLOAD );
 017E 00EA              ldi R16,160
 0180 00D0              rcall _SPI_ExchangeByte
 0182                   .dbline 289
 0182           ;     for( btmp = 0; btmp < length; btmp ++ )
 0182 AA24              clr R10
 0184 07C0              rjmp L35
 0186           L32:
 0186                   .dbline 290
 0186           ;     {
 0186                   .dbline 291
 0186           ;         SPI_ExchangeByte( *( pBuff + btmp ) );
 0186 EA2D              mov R30,R10
 0188 FF27              clr R31
 018A EE0D              add R30,R14
 018C FF1D              adc R31,R15
 018E 0081              ldd R16,z+0
 0190 00D0              rcall _SPI_ExchangeByte
 0192                   .dbline 292
 0192           ;     }
 0192           L33:
 0192                   .dbline 289
 0192 A394              inc R10
 0194           L35:
 0194                   .dbline 289
 0194 AC14              cp R10,R12
 0196 B8F3              brlo L32
 0198           X4:
 0198                   .dbline 293
 0198           ;     L01_CSN_HIGH( );
 0198                   .dbline 293
 0198 C29A              sbi 0x18,2
 019A                   .dbline 293
 019A BA9A              sbi 0x17,2
 019C                   .dbline 293
 019C                   .dbline 293
 019C                   .dbline -2
 019C           L29:
 019C                   .dbline 0 ; func end
 019C 00C0              rjmp pop_xgset30FC
 019E                   .dbsym r length 12 c
 019E                   .dbsym r btmp 10 c
 019E                   .dbsym r nBytes 10 c
 019E                   .dbsym r pBuff 14 pc
 019E                   .dbend
 019E                   .dbfunc e L01_WriteTXPayload_NoAck _L01_WriteTXPayload_NoAck fV
 019E           ;    Data_Length -> R20
 019E           ;           Data -> R10,R11
                        .even
 019E           _L01_WriteTXPayload_NoAck::
 019E 00D0              rcall push_xgset300C
 01A0 422F              mov R20,R18
 01A2 5801              movw R10,R16
 01A4                   .dbline -1
 01A4                   .dbline 305
 01A4           ; }
 01A4           ; /*
 01A4           ; ================================================================================
 01A4           ; Function : L01_WritePayload_NoAck( )
 01A4           ; Description : write data in tx mode, and prx won't return ack back
 01A4           ; Input : -Data, A buffer stores the address data
 01A4           ;         -Data_Length, How many bytes of the data buff
 01A4           ; Output: None
 01A4           ; ================================================================================
 01A4           ; */
 01A4           ; void L01_WriteTXPayload_NoAck( INT8U *Data, INT8U Data_Length )
 01A4           ; {
 01A4                   .dbline 306
 01A4           ;     if( Data_Length > 32 || Data_Length == 0 )
 01A4 80E2              ldi R24,32
 01A6 8417              cp R24,R20
 01A8 10F0              brlo L39
 01AA           X5:
 01AA 4423              tst R20
 01AC 09F4              brne L37
 01AE           X6:
 01AE           L39:
 01AE                   .dbline 307
 01AE           ;     {
 01AE                   .dbline 308
 01AE           ;         return ;
 01AE 10C0              rjmp L36
 01B0           L37:
 01B0                   .dbline 310
 01B0           ;     }
 01B0           ;     L01_CSN_LOW( );
 01B0                   .dbline 310
 01B0 C298              cbi 0x18,2
 01B2                   .dbline 310
 01B2 BA9A              sbi 0x17,2
 01B4                   .dbline 310
 01B4                   .dbline 310
 01B4                   .dbline 311
 01B4           ;     SPI_ExchangeByte( W_TX_PAYLOAD_NOACK );
 01B4 00EB              ldi R16,176
 01B6 00D0              rcall _SPI_ExchangeByte
 01B8 04C0              rjmp L41
 01BA           L40:
 01BA                   .dbline 313
 01BA           ;     while( Data_Length-- )
 01BA           ;     {
 01BA                   .dbline 314
 01BA           ;         SPI_ExchangeByte( *Data++ );
 01BA F501              movw R30,R10
 01BC 0191              ld R16,Z+
 01BE 5F01              movw R10,R30
 01C0 00D0              rcall _SPI_ExchangeByte
 01C2                   .dbline 315
 01C2           ;     }
 01C2           L41:
 01C2                   .dbline 312
 01C2 242E              mov R2,R20
 01C4 3324              clr R3
 01C6 4150              subi R20,1
 01C8 2220              tst R2
 01CA B9F7              brne L40
 01CC           X7:
 01CC                   .dbline 316
 01CC           ;     L01_CSN_HIGH( );
 01CC                   .dbline 316
 01CC C29A              sbi 0x18,2
 01CE                   .dbline 316
 01CE BA9A              sbi 0x17,2
 01D0                   .dbline 316
 01D0                   .dbline 316
 01D0                   .dbline -2
 01D0           L36:
 01D0                   .dbline 0 ; func end
 01D0 00C0              rjmp pop_xgset300C
 01D2                   .dbsym r Data_Length 20 c
 01D2                   .dbsym r Data 10 pc
 01D2                   .dbend
 01D2                   .dbfunc e L01_WriteRXPayload_InAck _L01_WriteRXPayload_InAck fV
 01D2           ;         length -> R12
 01D2           ;           btmp -> R10
 01D2           ;    Data_Length -> R10
 01D2           ;          pData -> R14,R15
                        .even
 01D2           _L01_WriteRXPayload_InAck::
 01D2 00D0              rcall push_xgset30FC
 01D4 A22E              mov R10,R18
 01D6 7801              movw R14,R16
 01D8                   .dbline -1
 01D8                   .dbline 328
 01D8           ; }
 01D8           ; /*
 01D8           ; ================================================================================
 01D8           ; Function : L01_WritePayload_InAck( )
 01D8           ; Description : write data in tx fifo when rx mode
 01D8           ; Input : -Data, A buffer stores the address data
 01D8           ;         -Data_Length, How many bytes of the data buff
 01D8           ; Output: None
 01D8           ; ================================================================================
 01D8           ; */
 01D8           ; void L01_WriteRXPayload_InAck( INT8U *pData, INT8U Data_Length )
 01D8           ; {
 01D8                   .dbline 329
 01D8           ;     INT8U length = ( Data_Length > 32 ) ? 32 : Data_Length;
 01D8 80E2              ldi R24,32
 01DA 8A15              cp R24,R10
 01DC 18F4              brsh L44
 01DE           X8:
 01DE 40E2              ldi R20,32
 01E0 50E0              ldi R21,0
 01E2 02C0              rjmp L45
 01E4           L44:
 01E4 4A2D              mov R20,R10
 01E6 5527              clr R21
 01E8           L45:
 01E8 C42E              mov R12,R20
 01EA                   .dbline 332
 01EA           ;     INT8U btmp;
 01EA           ; 
 01EA           ;     L01_CSN_LOW( );
 01EA                   .dbline 332
 01EA C298              cbi 0x18,2
 01EC                   .dbline 332
 01EC BA9A              sbi 0x17,2
 01EE                   .dbline 332
 01EE                   .dbline 332
 01EE                   .dbline 333
 01EE           ;     SPI_ExchangeByte( W_ACK_PAYLOAD );
 01EE 08EA              ldi R16,168
 01F0 00D0              rcall _SPI_ExchangeByte
 01F2                   .dbline 334
 01F2           ;     for( btmp = 0; btmp < length; btmp ++ )
 01F2 AA24              clr R10
 01F4 07C0              rjmp L49
 01F6           L46:
 01F6                   .dbline 335
 01F6           ;     {
 01F6                   .dbline 336
 01F6           ;         SPI_ExchangeByte( *( pData + btmp ) );
 01F6 EA2D              mov R30,R10
 01F8 FF27              clr R31
 01FA EE0D              add R30,R14
 01FC FF1D              adc R31,R15
 01FE 0081              ldd R16,z+0
 0200 00D0              rcall _SPI_ExchangeByte
 0202                   .dbline 337
 0202           ;     }
 0202           L47:
 0202                   .dbline 334
 0202 A394              inc R10
 0204           L49:
 0204                   .dbline 334
 0204 AC14              cp R10,R12
 0206 B8F3              brlo L46
 0208           X9:
 0208                   .dbline 338
 0208           ;     L01_CSN_HIGH( );
 0208                   .dbline 338
 0208 C29A              sbi 0x18,2
 020A                   .dbline 338
 020A BA9A              sbi 0x17,2
 020C                   .dbline 338
 020C                   .dbline 338
 020C                   .dbline -2
 020C           L43:
 020C                   .dbline 0 ; func end
 020C 00C0              rjmp pop_xgset30FC
 020E                   .dbsym r length 12 c
 020E                   .dbsym r btmp 10 c
 020E                   .dbsym r Data_Length 10 c
 020E                   .dbsym r pData 14 pc
 020E                   .dbend
 020E                   .dbfunc e L01_SetTXAddr _L01_SetTXAddr fV
 020E           ;         Length -> R12
 020E           ;    Addr_Length -> R12
 020E           ;          pAddr -> R10,R11
                        .even
 020E           _L01_SetTXAddr::
 020E 00D0              rcall push_xgset303C
 0210 C22E              mov R12,R18
 0212 5801              movw R10,R16
 0214 2197              sbiw R28,1
 0216                   .dbline -1
 0216                   .dbline 350
 0216           ; }
 0216           ; /*
 0216           ; ================================================================================
 0216           ; Function : L01_SetTXAddr( )
 0216           ; Description : Write address for the own device
 0216           ; Input : -pAddr, A buffer stores the address data
 0216           ;         -Addr_Length, How many bytes of the address
 0216           ; Output: None
 0216           ; ================================================================================
 0216           ; */
 0216           ; void L01_SetTXAddr( INT8U *pAddr, INT8U Addr_Length )
 0216           ; {
 0216                   .dbline 351
 0216           ;     INT8U Length = ( Addr_Length > 5 ) ? 5 : Addr_Length;
 0216 85E0              ldi R24,5
 0218 8C15              cp R24,R12
 021A 18F4              brsh L51
 021C           X10:
 021C 45E0              ldi R20,5
 021E 50E0              ldi R21,0
 0220 02C0              rjmp L52
 0222           L51:
 0222 4C2D              mov R20,R12
 0224 5527              clr R21
 0226           L52:
 0226 C42E              mov R12,R20
 0228                   .dbline 352
 0228           ;     L01_WriteMultiReg( L01REG_TX_ADDR, pAddr, Length );
 0228 C882              std y+0,R12
 022A 9501              movw R18,R10
 022C 00E1              ldi R16,16
 022E 15DF              rcall _L01_WriteMultiReg
 0230                   .dbline -2
 0230           L50:
 0230                   .dbline 0 ; func end
 0230 2196              adiw R28,1
 0232 00C0              rjmp pop_xgset303C
 0234                   .dbsym r Length 12 c
 0234                   .dbsym r Addr_Length 12 c
 0234                   .dbsym r pAddr 10 pc
 0234                   .dbend
 0234                   .dbfunc e L01_SetRXAddr _L01_SetRXAddr fV
 0234           ;           pipe -> R20
 0234           ;         Length -> R12
 0234           ;    Addr_Length -> R12
 0234           ;          pAddr -> R10,R11
 0234           ;        PipeNum -> R14
                        .even
 0234           _L01_SetRXAddr::
 0234 00D0              rcall push_xgset30FC
 0236 5901              movw R10,R18
 0238 E02E              mov R14,R16
 023A 2197              sbiw R28,1
 023C C984              ldd R12,y+9
 023E                   .dbline -1
 023E                   .dbline 365
 023E           ; }
 023E           ; /*
 023E           ; ================================================================================
 023E           ; Function : L01_SetRXAddr( )
 023E           ; Description : Write address for a RX pipe
 023E           ; Input : -PipeNum, number of the pipe
 023E           ;         -pAddr, A buffer stores the address data
 023E           ;         -Addr_Length, How many bytes of the address
 023E           ; Output: None
 023E           ; ================================================================================
 023E           ; */
 023E           ; void L01_SetRXAddr( INT8U PipeNum, INT8U *pAddr, INT8U Addr_Length )
 023E           ; {
 023E                   .dbline 366
 023E           ;     INT8U Length = ( Addr_Length > 5 ) ? 5 : Addr_Length;
 023E 85E0              ldi R24,5
 0240 8C15              cp R24,R12
 0242 18F4              brsh L54
 0244           X11:
 0244 45E0              ldi R20,5
 0246 50E0              ldi R21,0
 0248 02C0              rjmp L55
 024A           L54:
 024A 4C2D              mov R20,R12
 024C 5527              clr R21
 024E           L55:
 024E C42E              mov R12,R20
 0250                   .dbline 367
 0250           ;     INT8U pipe = ( PipeNum > 5 ) ? 5 : PipeNum;
 0250 85E0              ldi R24,5
 0252 8E15              cp R24,R14
 0254 18F4              brsh L56
 0256           X12:
 0256 45E0              ldi R20,5
 0258 50E0              ldi R21,0
 025A 02C0              rjmp L57
 025C           L56:
 025C 4E2D              mov R20,R14
 025E 5527              clr R21
 0260           L57:
 0260                   .dbline 369
 0260           ; 
 0260           ;     L01_WriteMultiReg( L01REG_RX_ADDR_P0 + pipe, pAddr, Length );
 0260 C882              std y+0,R12
 0262 9501              movw R18,R10
 0264 042F              mov R16,R20
 0266 065F              subi R16,246    ; addi 10
 0268 F8DE              rcall _L01_WriteMultiReg
 026A                   .dbline -2
 026A           L53:
 026A                   .dbline 0 ; func end
 026A 2196              adiw R28,1
 026C 00C0              rjmp pop_xgset30FC
 026E                   .dbsym r pipe 20 c
 026E                   .dbsym r Length 12 c
 026E                   .dbsym r Addr_Length 12 c
 026E                   .dbsym r pAddr 10 pc
 026E                   .dbsym r PipeNum 14 c
 026E                   .dbend
 026E                   .dbfunc e L01_SetSpeed _L01_SetSpeed fV
 026E           ;           btmp -> R20
 026E           ;          speed -> R22
                        .even
 026E           _L01_SetSpeed::
 026E 4A93              st -y,R20
 0270 6A93              st -y,R22
 0272 602F              mov R22,R16
 0274                   .dbline -1
 0274                   .dbline 380
 0274           ; }
 0274           ; /*
 0274           ; ================================================================================
 0274           ; Function : L01_SetSpeed )
 0274           ; Description : Send the communication speed of the RF device
 0274           ; Input :    speed,
 0274           ; Output: None
 0274           ; ================================================================================
 0274           ; */
 0274           ; void L01_SetSpeed( L01SPD speed )
 0274           ; {
 0274                   .dbline 381
 0274           ;       INT8U btmp = L01_ReadSingleReg( L01REG_RF_SETUP );
 0274 06E0              ldi R16,6
 0276 D1DE              rcall _L01_ReadSingleReg
 0278 402F              mov R20,R16
 027A                   .dbline 383
 027A           ; 
 027A           ;       btmp &= ~( ( 1<<5 ) | ( 1<<3 ) );
 027A 477D              andi R20,215
 027C                   .dbline 384
 027C           ;       if( speed == SPD_250K )         //250K
 027C 6623              tst R22
 027E 11F4              brne L59
 0280           X13:
 0280                   .dbline 385
 0280           ;       {
 0280                   .dbline 386
 0280           ;               btmp |= ( 1<<5 );
 0280 4062              ori R20,32
 0282                   .dbline 387
 0282           ;       }
 0282 07C0              rjmp L60
 0284           L59:
 0284                   .dbline 388
 0284           ;       else if( speed == SPD_1M )   //1M
 0284 6130              cpi R22,1
 0286 11F4              brne L61
 0288           X14:
 0288                   .dbline 389
 0288           ;       {
 0288                   .dbline 390
 0288           ;               btmp &= ~( ( 1<<5 ) | ( 1<<3 ) );
 0288 477D              andi R20,215
 028A                   .dbline 391
 028A           ;       }
 028A 03C0              rjmp L62
 028C           L61:
 028C                   .dbline 392
 028C           ;       else if( speed == SPD_2M )   //2M
 028C 6230              cpi R22,2
 028E 09F4              brne L63
 0290           X15:
 0290                   .dbline 393
 0290           ;       {
 0290                   .dbline 394
 0290           ;               btmp |= ( 1<<3 );
 0290 4860              ori R20,8
 0292                   .dbline 395
 0292           ;       }
 0292           L63:
 0292           L62:
 0292           L60:
 0292                   .dbline 397
 0292           ; 
 0292           ;       L01_WriteSingleReg( L01REG_RF_SETUP, btmp );
 0292 242F              mov R18,R20
 0294 06E0              ldi R16,6
 0296 CEDE              rcall _L01_WriteSingleReg
 0298                   .dbline -2
 0298           L58:
 0298                   .dbline 0 ; func end
 0298 6991              ld R22,y+
 029A 4991              ld R20,y+
 029C 0895              ret
 029E                   .dbsym r btmp 20 c
 029E                   .dbsym r speed 22 c
 029E                   .dbend
 029E                   .dbfunc e L01_SetPower _L01_SetPower fV
 029E           ;           btmp -> R20
 029E           ;          power -> R10
                        .even
 029E           _L01_SetPower::
 029E 00D0              rcall push_xgsetF00C
 02A0 A02E              mov R10,R16
 02A2                   .dbline -1
 02A2                   .dbline 408
 02A2           ; }
 02A2           ; /*
 02A2           ; ================================================================================
 02A2           ; Function : L01_SetPower )
 02A2           ; Description : Send the transmitt power of the device
 02A2           ; Input :    power
 02A2           ; Output: None
 02A2           ; ================================================================================
 02A2           ; */
 02A2           ; void L01_SetPower( L01PWR power )
 02A2           ; {
 02A2                   .dbline 409
 02A2           ;     INT8U btmp = L01_ReadSingleReg( L01REG_RF_SETUP ) & ~0x07;
 02A2 06E0              ldi R16,6
 02A4 BADE              rcall _L01_ReadSingleReg
 02A6 402F              mov R20,R16
 02A8 487F              andi R20,248
 02AA                   .dbline 410
 02AA           ;     switch( power )
 02AA 6A2D              mov R22,R10
 02AC 7727              clr R23
 02AE 6030              cpi R22,0
 02B0 6707              cpc R22,R23
 02B2 69F0              breq L69
 02B4           X16:
 02B4 6130              cpi R22,1
 02B6 E0E0              ldi R30,0
 02B8 7E07              cpc R23,R30
 02BA 51F0              breq L70
 02BC           X17:
 02BC 6230              cpi R22,2
 02BE E0E0              ldi R30,0
 02C0 7E07              cpc R23,R30
 02C2 41F0              breq L71
 02C4           X18:
 02C4 6330              cpi R22,3
 02C6 E0E0              ldi R30,0
 02C8 7E07              cpc R23,R30
 02CA 31F0              breq L72
 02CC           X19:
 02CC 06C0              rjmp L67
 02CE           L69:
 02CE                   .dbline 413
 02CE           ;     {
 02CE           ;         case P_F18DBM:
 02CE           ;             btmp |= PWR_18DB;
 02CE                   .dbline 414
 02CE           ;             break;
 02CE 05C0              rjmp L67
 02D0           L70:
 02D0                   .dbline 416
 02D0           ;         case P_F12DBM:
 02D0           ;             btmp |= PWR_12DB;
 02D0 4260              ori R20,2
 02D2                   .dbline 417
 02D2           ;             break;
 02D2 03C0              rjmp L67
 02D4           L71:
 02D4                   .dbline 419
 02D4           ;         case P_F6DBM:
 02D4           ;             btmp |= PWR_6DB;
 02D4 4460              ori R20,4
 02D6                   .dbline 420
 02D6           ;             break;
 02D6 01C0              rjmp L67
 02D8           L72:
 02D8                   .dbline 422
 02D8           ;         case P_0DBM:
 02D8           ;             btmp |= PWR_0DB;
 02D8 4660              ori R20,6
 02DA                   .dbline 423
 02DA           ;             break;
 02DA                   .dbline 425
 02DA           ;         default:
 02DA           ;             break;
 02DA           L67:
 02DA                   .dbline 427
 02DA           ;     }
 02DA           ;     L01_WriteSingleReg( L01REG_RF_SETUP, btmp );
 02DA 242F              mov R18,R20
 02DC 06E0              ldi R16,6
 02DE AADE              rcall _L01_WriteSingleReg
 02E0                   .dbline -2
 02E0           L65:
 02E0                   .dbline 0 ; func end
 02E0 00C0              rjmp pop_xgsetF00C
 02E2                   .dbsym r btmp 20 c
 02E2                   .dbsym r power 10 c
 02E2                   .dbend
 02E2                   .dbfunc e L01_WriteHoppingPoint _L01_WriteHoppingPoint fV
 02E2           ;      FreqPoint -> R20
                        .even
 02E2           _L01_WriteHoppingPoint::
 02E2 4A93              st -y,R20
 02E4 402F              mov R20,R16
 02E6                   .dbline -1
 02E6                   .dbline 438
 02E6           ; }
 02E6           ; /*
 02E6           ; ================================================================================
 02E6           ; Function : L01_WriteHoppingPoint( )
 02E6           ; Description : Set frequency for the device,must be 0-125
 02E6           ; Input : -FreqPoint, The hopping point
 02E6           ; Output: None
 02E6           ; ================================================================================
 02E6           ; */
 02E6           ; void L01_WriteHoppingPoint( INT8U FreqPoint )
 02E6           ; {
 02E6                   .dbline 439
 02E6           ;     L01_WriteSingleReg( L01REG_RF_CH, FreqPoint & 0x7F );
 02E6 242F              mov R18,R20
 02E8 2F77              andi R18,127
 02EA 05E0              ldi R16,5
 02EC A3DE              rcall _L01_WriteSingleReg
 02EE                   .dbline -2
 02EE           L73:
 02EE                   .dbline 0 ; func end
 02EE 4991              ld R20,y+
 02F0 0895              ret
 02F2                   .dbsym r FreqPoint 20 c
 02F2                   .dbend
 02F2                   .dbfunc e L01_IsTXEmpty _L01_IsTXEmpty fc
                        .even
 02F2           _L01_IsTXEmpty::
 02F2                   .dbline -1
 02F2                   .dbline 450
 02F2           ; }
 02F2           ; /*
 02F2           ; ================================================================================
 02F2           ; Function : L01_IsTXEmpty( )
 02F2           ; Description : Check the TX FIFO if is empty,1:empty, 0:not empty
 02F2           ; Input : -FreqPoint, The hopping point
 02F2           ; Output: 1:empty, 0:not empty
 02F2           ; ================================================================================
 02F2           ; */
 02F2           ; INT8U L01_IsTXEmpty( void )
 02F2           ; {
 02F2                   .dbline 451
 02F2           ;       return L01_ReadSingleReg( L01REG_FIFO_STATUS ) & ( 1<<TX_EMPTY );
 02F2 07E1              ldi R16,23
 02F4 92DE              rcall _L01_ReadSingleReg
 02F6 0071              andi R16,16
 02F8                   .dbline -2
 02F8           L74:
 02F8                   .dbline 0 ; func end
 02F8 0895              ret
 02FA                   .dbend
 02FA                   .dbfunc e L01_SetTRMode _L01_SetTRMode fV
 02FA           ;     controlreg -> R20
 02FA           ;           mode -> R22
                        .even
 02FA           _L01_SetTRMode::
 02FA 4A93              st -y,R20
 02FC 6A93              st -y,R22
 02FE 602F              mov R22,R16
 0300                   .dbline -1
 0300                   .dbline 465
 0300           ; }
 0300           ; 
 0300           ; /*
 0300           ; ================================================================================
 0300           ; Function : L01_SetTRMode( )
 0300           ; Description : Set the device as TX or RX mode
 0300           ; Input : -mode, the mode to be set
 0300           ;             @TX_MODE, TX mode
 0300           ;             @RX_MODE, RX mode
 0300           ; Output: None
 0300           ; ================================================================================
 0300           ; */
 0300           ; void L01_SetTRMode( L01MD mode )
 0300           ; {
 0300                   .dbline 466
 0300           ;     INT8U controlreg = L01_ReadSingleReg( L01REG_CONFIG );
 0300 0027              clr R16
 0302 8BDE              rcall _L01_ReadSingleReg
 0304 402F              mov R20,R16
 0306                   .dbline 467
 0306           ;     if( mode == TX_MODE )       { controlreg &= ~( 1<<PRIM_RX ); L01_SetCE( 0 ); }
 0306 6623              tst R22
 0308 21F4              brne L76
 030A           X20:
 030A                   .dbline 467
 030A                   .dbline 467
 030A 4E7F              andi R20,254
 030C                   .dbline 467
 030C 0027              clr R16
 030E 7BDE              rcall _L01_SetCE
 0310                   .dbline 467
 0310 05C0              rjmp L77
 0312           L76:
 0312                   .dbline 468
 0312           ;     else if( mode == RX_MODE )  { controlreg |= ( 1<<PRIM_RX ); L01_SetCE( 1 );}
 0312 6130              cpi R22,1
 0314 19F4              brne L78
 0316           X21:
 0316                   .dbline 468
 0316                   .dbline 468
 0316 4160              ori R20,1
 0318                   .dbline 468
 0318 01E0              ldi R16,1
 031A 75DE              rcall _L01_SetCE
 031C                   .dbline 468
 031C           L78:
 031C           L77:
 031C                   .dbline 470
 031C           ; 
 031C           ;     L01_WriteSingleReg( L01REG_CONFIG, controlreg );
 031C 242F              mov R18,R20
 031E 0027              clr R16
 0320 89DE              rcall _L01_WriteSingleReg
 0322                   .dbline -2
 0322           L75:
 0322                   .dbline 0 ; func end
 0322 6991              ld R22,y+
 0324 4991              ld R20,y+
 0326 0895              ret
 0328                   .dbsym r controlreg 20 c
 0328                   .dbsym r mode 22 c
 0328                   .dbend
 0328                   .dbfunc e L01_SetPowerDown _L01_SetPowerDown fV
 0328           ;     controlreg -> R20
                        .even
 0328           _L01_SetPowerDown::
 0328 4A93              st -y,R20
 032A                   .dbline -1
 032A                   .dbline 481
 032A           ; }
 032A           ; /*
 032A           ; ================================================================================
 032A           ; Function : L01_SetPowerDown( )
 032A           ; Description : Set the nRF24L01 into PowerDown mode
 032A           ; Input : None
 032A           ; Output: None
 032A           ; ================================================================================
 032A           ; */
 032A           ; void L01_SetPowerDown( void )
 032A           ; {
 032A                   .dbline 482
 032A           ;       INT8U controlreg = L01_ReadSingleReg( L01REG_CONFIG );
 032A 0027              clr R16
 032C 76DE              rcall _L01_ReadSingleReg
 032E 402F              mov R20,R16
 0330                   .dbline 483
 0330           ;     L01_WriteSingleReg( L01REG_CONFIG, controlreg & ( ~( 1<<PWR_UP ) ) );
 0330 242F              mov R18,R20
 0332 2D7F              andi R18,253
 0334 0027              clr R16
 0336 7EDE              rcall _L01_WriteSingleReg
 0338                   .dbline -2
 0338           L80:
 0338                   .dbline 0 ; func end
 0338 4991              ld R20,y+
 033A 0895              ret
 033C                   .dbsym r controlreg 20 c
 033C                   .dbend
 033C                   .dbfunc e L01_SetPowerUp _L01_SetPowerUp fV
 033C           ;     controlreg -> R20
                        .even
 033C           _L01_SetPowerUp::
 033C 4A93              st -y,R20
 033E                   .dbline -1
 033E                   .dbline 494
 033E           ; }
 033E           ; /*
 033E           ; ================================================================================
 033E           ; Function : L01_SetPowerUp( )
 033E           ; Description : Set the nRF24L01 into Powerup mode
 033E           ; Input : None
 033E           ; Output: None
 033E           ; ================================================================================
 033E           ; */
 033E           ; void L01_SetPowerUp( void )
 033E           ; {
 033E                   .dbline 495
 033E           ;       INT8U controlreg = L01_ReadSingleReg( L01REG_CONFIG );
 033E 0027              clr R16
 0340 6CDE              rcall _L01_ReadSingleReg
 0342 402F              mov R20,R16
 0344                   .dbline 496
 0344           ;     L01_WriteSingleReg( L01REG_CONFIG, controlreg | ( 1<<PWR_UP ) );
 0344 242F              mov R18,R20
 0346 2260              ori R18,2
 0348 0027              clr R16
 034A 74DE              rcall _L01_WriteSingleReg
 034C                   .dbline -2
 034C           L81:
 034C                   .dbline 0 ; func end
 034C 4991              ld R20,y+
 034E 0895              ret
 0350                   .dbsym r controlreg 20 c
 0350                   .dbend
                        .area lit(rom, con, rel)
 0000           L83:
 0000 9988              .byte 153,136
 0002 2136              .byte 33,54
 0004 AB                .byte 171
                        .area text(rom, con, rel)
 0350                   .dbfile F:\产品\ODMPRO~1\E06-RFTB\E06-AVR\DEMO_AVR\nRF24L01P\Source\nRF24L01.c
 0350                   .dbfunc e L01_Init _L01_Init fV
 0350           ;            tmp -> R10
 0350           ;           addr -> y+1
                        .even
 0350           _L01_Init::
 0350 AA92              st -y,R10
 0352 2697              sbiw R28,6
 0354                   .dbline -1
 0354                   .dbline 507
 0354           ; }
 0354           ; /*
 0354           ; ================================================================================
 0354           ; Function : L01_Init( )
 0354           ; Description : Initialize the nRF24L01
 0354           ; Input : None
 0354           ; Output: None
 0354           ; ================================================================================
 0354           ; */
 0354           ; void L01_Init( void )
 0354           ; {
 0354                   .dbline 508
 0354           ;     INT8U addr[5] = {INIT_ADDR};
 0354 80E0              ldi R24,<L83
 0356 90E0              ldi R25,>L83
 0358 FE01              movw R30,R28
 035A 3196              adiw R30,1
 035C 05E0              ldi R16,5
 035E 10E0              ldi R17,0
 0360 FA93              st -y,R31
 0362 EA93              st -y,R30
 0364 9A93              st -y,R25
 0366 8A93              st -y,R24
 0368 00D0              rcall asgncblk
 036A                   .dbline 510
 036A           ; 
 036A           ;       INT8U tmp = L01_GetCEStatus( );
 036A 4ADE              rcall _L01_GetCEStatus
 036C A02E              mov R10,R16
 036E                   .dbline 511
 036E           ;     L01_SetCE( 0 );
 036E 0027              clr R16
 0370 4ADE              rcall _L01_SetCE
 0372                   .dbline 512
 0372           ;       L01_SetPowerDown( );
 0372 DADF              rcall _L01_SetPowerDown
 0374                   .dbline 513
 0374           ;     L01_ClearIRQ( IRQ_ALL );
 0374 00E7              ldi R16,112
 0376 B4DE              rcall _L01_ClearIRQ
 0378                   .dbline 516
 0378           ; #if DYNAMIC_PACKET == 1
 0378           ;     //dynamic payload length
 0378           ;     L01_WriteSingleReg( L01REG_DYNPD, ( 1<<0 ) );//Enable pipe 0 dynamic payload length
 0378 21E0              ldi R18,1
 037A 0CE1              ldi R16,28
 037C 5BDE              rcall _L01_WriteSingleReg
 037E                   .dbline 517
 037E           ;     L01_WriteSingleReg( L01REG_FEATRUE, 0x06 );
 037E 26E0              ldi R18,6
 0380 0DE1              ldi R16,29
 0382 58DE              rcall _L01_WriteSingleReg
 0384                   .dbline 518
 0384           ;     L01_ReadSingleReg( L01REG_DYNPD );
 0384 0CE1              ldi R16,28
 0386 49DE              rcall _L01_ReadSingleReg
 0388                   .dbline 519
 0388           ;     L01_ReadSingleReg( L01REG_FEATRUE );
 0388 0DE1              ldi R16,29
 038A 47DE              rcall _L01_ReadSingleReg
 038C                   .dbline 525
 038C           ; #elif DYNAMIC_PACKET == 0
 038C           ;     //Fixed packet length
 038C           ;     L01_WriteSingleReg( L01REG_RX_PW_P0, FIXED_PACKET_LEN );
 038C           ; #endif//DYNAMIC_PACKET
 038C           ; 
 038C           ;     L01_WriteSingleReg( L01REG_CONFIG,/* ( 1<<MASK_TX_DS ) |*////receive interrupt
 038C 28E0              ldi R18,8
 038E 0027              clr R16
 0390 51DE              rcall _L01_WriteSingleReg
 0392                   .dbline 527
 0392           ;                                       ( 1<<EN_CRC ) );     //Enable CRC, 1 byte
 0392           ;     L01_WriteSingleReg( L01REG_EN_AA, ( 1<<ENAA_P0 ) );   //Auto ack in pipe 0
 0392 21E0              ldi R18,1
 0394 01E0              ldi R16,1
 0396 4EDE              rcall _L01_WriteSingleReg
 0398                   .dbline 528
 0398           ;     L01_WriteSingleReg( L01REG_EN_RXADDR, ( 1<<ERX_P0 ) );//Enable pipe 0 receive
 0398 21E0              ldi R18,1
 039A 02E0              ldi R16,2
 039C 4BDE              rcall _L01_WriteSingleReg
 039E                   .dbline 529
 039E           ;     L01_WriteSingleReg( L01REG_SETUP_AW, AW_5BYTES );     //Address width : 5Byte
 039E 23E0              ldi R18,3
 03A0 03E0              ldi R16,3
 03A2 48DE              rcall _L01_WriteSingleReg
 03A4                   .dbline 530
 03A4           ;     L01_WriteSingleReg( L01REG_RETR, (((REPEAT_TIME/250)&0X0F)<<4) |
 03A4 2FE8              ldi R18,143
 03A6 04E0              ldi R16,4
 03A8 45DE              rcall _L01_WriteSingleReg
 03AA                   .dbline 532
 03AA           ;                         ( REPEAT_CNT & 0x0F ) );          //repeat SETTING
 03AA           ;     L01_WriteSingleReg( L01REG_RF_CH, 0x0 );             //Initial channel
 03AA 2227              clr R18
 03AC 05E0              ldi R16,5
 03AE 42DE              rcall _L01_WriteSingleReg
 03B0                   .dbline 533
 03B0           ;     L01_WriteSingleReg( L01REG_RF_SETUP, 0x27 );
 03B0 27E2              ldi R18,39
 03B2 06E0              ldi R16,6
 03B4 3FDE              rcall _L01_WriteSingleReg
 03B6                   .dbline 534
 03B6           ;     L01_SetTXAddr( &addr[0], 5 );                          //Set TX address
 03B6 25E0              ldi R18,5
 03B8 8E01              movw R16,R28
 03BA 0F5F              subi R16,255  ; offset = 1
 03BC 1F4F              sbci R17,255
 03BE 27DF              rcall _L01_SetTXAddr
 03C0                   .dbline 535
 03C0           ;     L01_SetRXAddr( 0, &addr[0], 5 );                       //Set RX address
 03C0 85E0              ldi R24,5
 03C2 8883              std y+0,R24
 03C4 9E01              movw R18,R28
 03C6 2F5F              subi R18,255  ; offset = 1
 03C8 3F4F              sbci R19,255
 03CA 0027              clr R16
 03CC 33DF              rcall _L01_SetRXAddr
 03CE                   .dbline 536
 03CE           ;       L01_SetPowerUp( );
 03CE B6DF              rcall _L01_SetPowerUp
 03D0                   .dbline -2
 03D0           L82:
 03D0                   .dbline 0 ; func end
 03D0 2696              adiw R28,6
 03D2 A990              ld R10,y+
 03D4 0895              ret
 03D6                   .dbsym r tmp 10 c
 03D6                   .dbsym l addr 1 A[5:5]c
 03D6                   .dbend
 03D6           ; }
 03D6           ; /*
 03D6           ; ================================================================================
 03D6           ; ====================================End of file=================================
 03D6           ; ================================================================================
 03D6           ; */
